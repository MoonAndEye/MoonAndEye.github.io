<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-10-13T23:08:07+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Marv[in]sight</title><subtitle>Welcome to my blog, a vibrant space dedicated to software development, investment insights, personal experiences, and life stories. Join me as we explore a diverse array of topics. I aim to share my journey and insights, fostering a community where we can interact, learn from each other, and grow together.</subtitle><author><name>Marvin Lin</name></author><entry xml:lang="zh"><title type="html">AI如何讓世界變得更美好 Dario Amodei by Claude 創辦人 機翻</title><link href="http://localhost:4000/zh/programming/how-ai-transform-the-world-better.html" rel="alternate" type="text/html" title="AI如何讓世界變得更美好 Dario Amodei by Claude 創辦人 機翻" /><published>2024-10-13T16:20:00+08:00</published><updated>2024-10-13T16:20:00+08:00</updated><id>http://localhost:4000/zh/programming/how-ai-transform-the-world-better</id><content type="html" xml:base="http://localhost:4000/zh/programming/how-ai-transform-the-world-better.html">&lt;h3 id=&quot;tldr&quot;&gt;TL;DR&lt;/h3&gt;
&lt;h3 id=&quot;強大ai-如何讓世界變得更美好五大領域的潛在益處&quot;&gt;強大AI 如何讓世界變得更美好：五大領域的潛在益處&lt;/h3&gt;

&lt;h4 id=&quot;notebooklm-整理出來的摘要但建議有空的話還是把原文看完會更有感覺&quot;&gt;NotebookLM 整理出來的摘要，但建議有空的話，還是把原文看完，會更有感覺。&lt;/h4&gt;

&lt;p&gt;Dario Amodei 在其文章 “Machines of Loving Grace” 中探討了強大AI 的潛在益處，並將這些益處集中在五個關鍵領域：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 生物學與健康&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AI 將加速生物學研究的整個過程，包括設計和執行實驗、發明新的測量技術等。&lt;/li&gt;
  &lt;li&gt;AI 可以幫助我們發現更多類似 CRISPR、mRNA 疫苗、CAR-T 細胞療法等突破性技術，這些技術具有高智力回報，可以顯著提高我們對生物過程的理解和控制能力。&lt;/li&gt;
  &lt;li&gt;AI 有可能在 5 到 10 年內實現相當於人類生物學家在未來 50 到 100 年內才能取得的生物學和醫學進展，Amodei 將此稱為「壓縮的 21 世紀」。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;預期進展：&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;可靠地預防和治療幾乎所有自然傳染病&lt;/li&gt;
      &lt;li&gt;消除大多數癌症&lt;/li&gt;
      &lt;li&gt;有效地預防和治療遺傳疾病&lt;/li&gt;
      &lt;li&gt;預防阿茲海默症&lt;/li&gt;
      &lt;li&gt;改善大多數其他疾病的治療，如糖尿病、肥胖症、心臟病等&lt;/li&gt;
      &lt;li&gt;實現「生物自由」，讓人們可以完全控制自己的體重、外貌、生育等生物過程&lt;/li&gt;
      &lt;li&gt;人類壽命倍增至 150 歲&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 神經科學與心理健康&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AI 可以幫助我們更好地理解大腦，開發出治療大多數心理疾病的方法，例如成癮、抑鬱、精神分裂症等。&lt;/li&gt;
  &lt;li&gt;AI 可以通過以下四種途徑加速神經科學進展：
    &lt;ul&gt;
      &lt;li&gt;加速傳統的分子生物學、化學和基因學研究&lt;/li&gt;
      &lt;li&gt;開發更精細的神經測量和干預工具&lt;/li&gt;
      &lt;li&gt;推動先進的計算神經科學研究&lt;/li&gt;
      &lt;li&gt;改進行為干預措施&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;預期進展：&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;治癒大多數心理疾病&lt;/li&gt;
      &lt;li&gt;解決一些結構性心理問題，如精神病和智力障礙&lt;/li&gt;
      &lt;li&gt;通過基因預防來防止心理疾病的發生&lt;/li&gt;
      &lt;li&gt;解決日常的心理問題，例如憤怒、注意力不集中、焦慮等&lt;/li&gt;
      &lt;li&gt;提升人類基本心理狀態，讓人們體驗到更多啟示、創造力、慈悲、滿足等非凡時刻&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. 經濟發展與貧困&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AI 可以幫助發展中國家追趕發達國家，促進全球經濟增長，並通過優化資源分配來解決貧困和不平等問題。&lt;/li&gt;
  &lt;li&gt;AI 可以協助制定更有效的經濟政策，並推廣 AI 加速的技術，例如能源技術、運輸無人機、 improved building materials、更高效的物流和分配等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;預期進展：&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;將 AI 驅動的健康干預措施普及到發展中國家&lt;/li&gt;
      &lt;li&gt;實現發展中國家每年 20% 的 GDP 增長率&lt;/li&gt;
      &lt;li&gt;通過 AI 驅動的「第二次綠色革命」來確保糧食安全&lt;/li&gt;
      &lt;li&gt;減緩氣候變化的影響&lt;/li&gt;
      &lt;li&gt;解決國內的不平等問題&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4. 和平與治理&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AI 可以增強民主國家在世界舞台上的影響力，促進民主和人權的發展，並可能通過提供公正的決策和改善政府服務來改善民主制度。&lt;/li&gt;
  &lt;li&gt;AI 可以幫助民主國家在信息戰中取得優勢，反制威權國家的宣傳活動，並保障信息自由流通。&lt;/li&gt;
  &lt;li&gt;AI 可以協助建立更公正的法律和司法系統，減少偏見和歧視。&lt;/li&gt;
  &lt;li&gt;AI 可以提高政府服務的效率和公平性，例如醫療服務、稅務、社會保障等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;5. 工作與意義&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AI 可能會取代一些工作，但 Amodei 認為人類可以通過比較優勢和專注於人際關係和創造性活動來找到新的意義。&lt;/li&gt;
  &lt;li&gt;AI 可以讓人們從繁重的勞動中解放出來，有更多時間追求個人興趣和發展人際關係。&lt;/li&gt;
  &lt;li&gt;AI 可以創造出一個資源豐富的世界，讓人們不必為了生存而工作，可以自由地追求自我實現。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Amodei 承認，要實現這些美好願景，需要克服許多挑戰，包括技術發展的限制、社會和政治障礙以及對未來經濟模式的擔憂。但他仍然對 AI 的未來充滿希望，並呼籲所有人共同努力，克服這些挑戰，創造一個更美好的世界。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;以下是機翻原文&lt;/p&gt;

&lt;h2 id=&quot;ai如何讓世界變得更美好&quot;&gt;AI如何讓世界變得更美好&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Dario Amodei&lt;/li&gt;
  &lt;li&gt;2024年10月&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我經常思考和討論強大AI的風險。我擔任Anthropic的CEO，這家公司做了大量研究以減少這些風險。基於這一點，有時人們會認為我是一個悲觀主義者，甚至是認為AI會帶來主要負面影響的「末日論者」。但我並不這麼認為。事實上，我專注於風險的主要原因之一是，這些風險是我們與我所見的基本上積極未來之間的唯一障礙。我認為大多數人低估了AI的巨大潛力，就像他們低估了它的風險一樣。&lt;/p&gt;

&lt;p&gt;在這篇文章中，我嘗試勾勒出這種潛力可能是什麼樣子——如果一切順利，擁有強大AI的世界可能會是什麼樣子。當然，沒有人能夠確定地預測未來，強大AI的影響可能比以往的技術變革更加不可預測，因此這一切都難免是猜測。然而，我的目標是至少做出有根據且有價值的猜測，哪怕大多數細節可能是錯的。我詳細描述了許多細節，因為我認為具體的願景比高度概括和抽象的討論更有助於推動討論。&lt;/p&gt;

&lt;p&gt;然而，首先我想簡要說明為什麼我和Anthropic並沒有多談強大AI的正面作用，並且為什麼我們可能仍然會繼續更多地討論風險。尤其是，我基於以下幾點做出了這個選擇：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最大化影響力。AI技術的基本發展及其許多（但不是全部）好處似乎是不可避免的（除非風險破壞了一切），並且主要由強大的市場力量驅動。而另一方面，風險並非必然的，我們的行動可以極大地改變其發生的可能性。&lt;/li&gt;
  &lt;li&gt;避免宣傳的感覺。當AI公司談論AI的所有驚人好處時，可能會給人一種宣傳的印象，或者似乎他們在試圖轉移對負面影響的注意。我也認為，從原則上講，花過多時間“談論自己的書”對靈魂不好。&lt;/li&gt;
  &lt;li&gt;避免過度自負。我經常對許多AI風險公眾人物（更不用說AI公司領導者）談論後AGI時代的方式感到不滿，仿佛他們的使命是單槍匹馬地實現這一目標，就像先知帶領他的子民走向救贖。我認為，將公司視為單方面塑造世界是危險的，並且將實際技術目標視為宗教性任務也是危險的。&lt;/li&gt;
  &lt;li&gt;避免科幻包袱。儘管我認為大多數人低估了強大AI的上升空間，但討論激進AI未來的小圈子往往以過於科幻的語氣進行討論（如提及心靈上載、太空探索或一般的賽博朋克氛圍）。我認為這會讓人們不那麼認真看待這些主張，並賦予它們一種不現實的感覺。要說清楚，問題不在於這些技術是否可能或可能發生（本文主體部分深入討論了這一點）——更多的是這種「氛圍」隱含地帶來了一些文化包袱和未表達的假設，關於哪種未來是可取的，社會問題將如何發展等。結果通常讀起來像是為一小部分文化設計的幻想，卻讓大多數人感到排斥。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;儘管有上述擔憂，我確實認為討論擁有強大AI的美好世界是重要的，同時盡力避免上述陷阱。事實上，我認為擁有真正鼓舞人心的未來願景是至關重要的，而不僅僅是滅火的計劃。許多強大AI的影響是對抗性的或危險的，但最終我們需要一些我們正在為之奮鬥的東西，一個每個人都能變得更好的正和結果，一個能讓人們團結起來，超越爭吵，面對前方挑戰的目標。恐懼是一種動機，但它不夠，我們也需要希望。&lt;/p&gt;

&lt;p&gt;強大AI的正面應用非常廣泛（包括機器人、製造業、能源等），但我將重點關注我認為最有潛力直接改善人類生活質量的幾個領域。我最期待的五個領域是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;生物學與身體健康&lt;/li&gt;
  &lt;li&gt;神經科學與心理健康&lt;/li&gt;
  &lt;li&gt;經濟發展與貧困&lt;/li&gt;
  &lt;li&gt;和平與治理&lt;/li&gt;
  &lt;li&gt;工作與意義&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我的預測會被大多數標準視為激進的（除了科幻的「奇點」願景之外），但我是認真且真誠的。正如我前面提到的，這一切都可能是錯的，但我至少嘗試以半分析的方式評估各個領域可能加速的進展，以及這在實踐中可能意味著什麼。我很幸運在生物學和神經科學領域有專業經驗，並且對經濟發展有相當多的認識，儘管如此，我肯定會犯許多錯誤。撰寫這篇文章讓我意識到，集合一群生物學、經濟學、國際關係等領域的專家來撰寫更好、更有見識的版本，將會是非常有價值的。我的努力應該被視為這個群體討論的起始點。&lt;/p&gt;

&lt;p&gt;基本假設與框架&lt;/p&gt;

&lt;p&gt;為了使這篇文章更加精確和有根據，我認為明確定義「強大AI」是必要的（即從這個點開始的5到10年內的時間框架），同時也應該提出一個框架來思考這種AI出現後的影響。&lt;/p&gt;

&lt;p&gt;「強大AI」（我不喜歡AGI這個術語）的具體形態將是什麼，以及何時（或者是否）會出現，是一個非常龐大的話題。我已經在公開場合討論過這個話題，未來很可能會寫一篇專門的文章來探討（我可能會這麼做）。顯然，許多人懷疑強大的AI是否會很快被開發出來，甚至有些人懷疑它是否會被開發出來。我認為它可能最早會在2026年出現，但也有一些情況可能導致其延遲更長時間。不過，為了這篇文章的目的，我希望暫時擱置這些問題，假設它會在不久的將來出現，並專注於在這之後的5到10年內可能發生的事情。我還想假設一個對這種系統的定義，即它的能力以及如何運作，儘管對此仍存在一些爭議。&lt;/p&gt;

&lt;p&gt;我心目中的強大AI是一種AI模型——可能形式上類似於今天的大型語言模型（LLM），儘管它可能基於不同的架構，可能包含多個交互模型，也可能以不同的方式進行訓練——具備以下特徵：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;純智力方面&lt;/strong&gt;，它在大多數相關領域（生物學、編程、數學、工程、寫作等）中比諾貝爾獎得主更聰明。這意味著它能夠證明尚未解決的數學定理，寫出極好的小說，從零開始撰寫複雜的代碼庫等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;除了只是「你對話的一個聰明東西」之外，它擁有所有人類在虛擬工作中的「接口」，包括文本、音頻、視頻、鼠標和鍵盤控制以及互聯網訪問。它能夠參與由這些接口啟用的任何行動、溝通或遠程操作，包括在互聯網上執行操作，向人類發出或接收指令，訂購材料，指導實驗，觀看視頻，製作視頻等。它在所有這些任務中的技能再次超過世界上最能幹的人類。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;它不僅僅是被動地回答問題；相反，它可以接受需要數小時、數天或數週才能完成的任務，並像一個聰明的員工一樣自主地執行這些任務，必要時尋求澄清。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;它沒有實體（除了存在於電腦屏幕上），但它可以通過計算機控制現有的物理工具、機器人或實驗室設備；理論上，它甚至可以設計自己使用的機器人或設備。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;訓練模型所需的資源可以被重新用於運行數百萬個實例（預計到2027年左右，這將符合預期的集群規模），並且該模型可以以約人類速度的10倍到100倍吸收信息和生成行動。不過，它可能會受到物理世界或與其交互的軟件響應時間的限制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;這些數百萬個實例可以獨立處理無關的任務，或者在需要時，像人類協作一樣共同工作，也許不同的子群體經過微調，特別擅長某些任務。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我們可以將這總結為一個「數據中心裡的天才國度」。&lt;/p&gt;

&lt;p&gt;如此強大的實體顯然能夠以非常快的速度解決非常困難的問題，但確定其速度並非易事。有兩種「極端」的立場我都認為是錯誤的。首先，你可能認為世界會在幾秒鐘或幾天內被瞬間改變（「奇點」），因為超級智能會自我增強，幾乎立即解決所有科學、工程和操作問題。問題在於，現實中存在物理和實際的限制，例如建造硬件或進行生物實驗。即使是一個新的天才國度也會遇到這些限制。智慧可能非常強大，但它不是魔法仙塵。&lt;/p&gt;

&lt;p&gt;其次，相反地，你可能認為技術進步已經飽和，或者受限於現實世界的數據或社會因素，而超越人類的智能將增加甚少。這同樣是不可想象的——我能想到數百個科學或社會問題，如果有一群非常聰明的人，進展會大大加快，尤其是當他們不僅限於分析，還能在現實世界中實現時。&lt;/p&gt;

&lt;p&gt;我認為真相很可能是這兩種極端圖景的混合體，它隨著任務和領域而變化，細節非常微妙。我相信我們需要新的框架來以有生產力的方式思考這些細節。&lt;/p&gt;

&lt;p&gt;經濟學家經常談論「生產要素」：勞動、土地和資本。「邊際回報」這個詞表達了這樣的想法，即在特定情況下，某個要素可能是限制因素。例如，空軍需要飛機和飛行員，而如果沒有足夠的飛機，僅僅增加飛行員並沒有幫助。我相信，在AI時代，我們應該談論「智力的邊際回報」，並試圖弄清楚與智力互補的其他要素是什麼，當智力非常高時，這些要素成為限制因素。我們不習慣以這種方式思考——詢問「變得更聰明對這項任務有多少幫助，以及在多長時間範圍內？」——但這似乎是概念化一個擁有非常強大AI的世界的正確方法。&lt;/p&gt;

&lt;p&gt;我的猜測是限制或互補於智力的要素清單包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;外部世界的速度&lt;/strong&gt;。智能代理需要在現實世界中交互以完成任務並學習，但世界的運轉速度是固定的。實驗室中的細胞和動物運行有固定的速度，實驗需要時間，這有時是無法減少的。同樣的道理適用於硬件、材料科學、與人溝通，甚至是我們現有的軟件基礎設施。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基於此框架，我將嘗試為引言中提到的五個領域提供答案。&lt;/p&gt;

&lt;p&gt;—
我的猜測是限制或互補於智力的要素清單包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;外部世界的速度&lt;/strong&gt;。智能代理需要在現實世界中互動才能完成任務，並且學習過程也依賴於這種互動。但是現實世界的運作速度是固定的。細胞和動物的運行速度固定，因此在它們上的實驗需要一定的時間，有時是不可減少的。硬體、材料科學、與人類的交流，甚至是現有的軟體基礎設施，都存在類似的限制。此外，在科學領域，許多實驗往往需要一個接一個地進行，依次學習或建構前一個實驗的成果。因此，完成像開發癌症治療這樣的大型專案的速度可能有不可縮短的最低限度，即使智力水平不斷提高。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;對資料的需求&lt;/strong&gt;。有時缺少原始資料，在缺少資料的情況下，再高的智力也無濟於事。現代的粒子物理學家非常聰明，開發了廣泛的理論，但由於粒子加速器提供的數據非常有限，他們無法在理論間做出選擇。即便他們擁有超高智力，也不見得能大幅提高進展——除了可能加快建造更大的加速器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;內在的複雜性&lt;/strong&gt;。有些事物天生是不可預測或混沌的，即使是最強大的AI也無法比現代的人類或電腦做出明顯更好的預測或解析。例如，即使是極其強大的AI，也只能在混沌系統中比當前的人類和電腦稍微多預測一點點時間。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;人類的限制&lt;/strong&gt;。許多事情不能在不違法、不傷害人類或不破壞社會的前提下完成。一個對齊的AI（aligned AI）不會希望做這些事（而如果我們面對的是不對齊的AI，我們又回到了討論風險的話題）。許多人類社會結構是低效的，甚至是有害的，但在遵守臨床試驗等法律要求、人們改變習慣的意願或政府行為的限制下，這些結構很難改變。某些技術進步在技術上非常有效，但受到法規或恐懼的影響，實際影響卻大打折扣，例子包括核能、超音速飛行，甚至是電梯。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;物理法則&lt;/strong&gt;。這是第一點的更嚴格版本。某些物理法則顯然是不可打破的。例如，不可能超越光速，布丁不會自行恢復原狀，芯片每平方厘米的晶體管數量也有限，因為再多它們就會變得不可靠。計算需要每位元刪除的最小能量，這限制了世界上計算的密度。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，還有一個基於時間尺度的區別。某些在短期內是硬性限制的事物，隨著智力的增強，可能在長期內變得更靈活。例如，智力可以用於開發新的實驗範式，允許我們在試管中學習過去需要活體動物實驗才能獲得的知識，或者建造新的工具來收集數據（例如更大的粒子加速器），或者（在道德範圍內）找到繞過人類限制的方法（例如幫助改進臨床試驗系統、創建新的司法管轄區以減少官僚障礙，或改進科學本身以使人類臨床試驗變得不那麼必要或更便宜）。&lt;/p&gt;

&lt;p&gt;因此，我們應該想像一幅圖景，智力最初受限於其他生產要素，但隨著時間推移，智力本身逐漸繞過這些要素，即使它們永遠不會完全消失（某些事情，例如物理法則，是絕對的）。關鍵問題是這一切會發生得多快，並以什麼順序發生。&lt;/p&gt;

&lt;p&gt;基於以上框架，我將嘗試針對引言中提到的五個領域做出回答。&lt;/p&gt;

&lt;h3 id=&quot;1-生物學與健康&quot;&gt;1. 生物學與健康&lt;/h3&gt;

&lt;p&gt;生物學可能是科學進步最有潛力直接改善人類生活質量的領域。在過去的世紀裡，一些最古老的人類疾患（例如天花）終於被消滅，但還有更多疾病依然存在，戰勝它們將是巨大的慈善事業成就。超越治癒疾病，生物科學原則上還可以改善人類健康的基礎質量，通過延長健康的壽命、增加我們對自己生物過程的控制自由，以及解決我們目前認為是人類固有條件的日常問題。&lt;/p&gt;

&lt;p&gt;在前一節的「限制要素」語言中，直接將智力應用於生物學的主要挑戰是數據、物理世界的速度和內在的複雜性（事實上，這三者是互相關聯的）。人類的限制在後期（臨床試驗階段）也起作用。讓我們一一探討這些問題。&lt;/p&gt;

&lt;p&gt;細胞、動物甚至化學過程的實驗受到物理世界速度的限制：許多生物學的實驗程序涉及培養細菌或其他細胞，或者僅僅等待化學反應發生，這有時可能需要數天甚至數週的時間，無法明顯加快進度。動物實驗可能需要數月，人體實驗則常常需要數年（或更長時間進行長期結果研究）。與此相關，數據通常短缺——不是在數量上，而是在質量上：總是缺乏清晰、明確的數據來隔離感興趣的生物效應，從其他10,000種伴隨發生的事情中分離出來，或者在某個過程中進行因果干預，或者直接測量某些效應（而不是通過某種間接或噪聲方式推測其後果）。即便是我在使用質譜技術收集的巨大分子數據（例如蛋白質組數據），也存在噪音且遺漏了許多信息（這些蛋白質存在於哪些細胞中？在細胞的哪個部分？處於細胞週期的哪個階段？）。&lt;/p&gt;

&lt;p&gt;部分原因與數據問題相關的是內在的複雜性：如果你曾經看過人類代謝的生化圖譜，你就會知道要隔離這個複雜系統中的任何部分的效應是非常困難的，而要以精確或可預測的方式干預該系統則更難。最後，超出僅僅進行人體實驗的內在時間之外，實際的臨床試驗還涉及許多官僚和法規要求，這在許多人的觀點中（包括我）增加了不必要的時間並延緩了進展。&lt;/p&gt;

&lt;p&gt;鑑於這一切，許多生物學家長期以來對AI和「大數據」在生物學中的價值持懷疑態度。歷史上，數學家、計算機科學家和物理學家在過去30年裡將他們的技能應用於生物學，儘管取得了一定的成功，但並沒有實現最初期望的真正顛覆性影響。隨著重大且革命性的突破，如AlphaFold（該技術已經為其創造者贏得了諾貝爾化學獎）和AlphaProteo的出現，這種懷疑有所減少，但仍然存在一種觀點，認為AI僅在有限的情況下有用。常見的說法是：「AI可以更好地分析你的數據，但它無法產生更多數據或改善數據的質量。垃圾進，垃圾出。」&lt;/p&gt;

&lt;p&gt;但我認為這種悲觀的觀點是用錯了方法思考AI。如果我們對AI進步的核心假設是正確的，那麼思考AI的正確方式不是將其視為數據分析的工具，而是將其視為虛擬生物學家，執行所有生物學家做的工作，包括在現實世界中設計和運行實驗（通過控制實驗室機器人或僅僅告訴人類應該進行哪些實驗——就像一名主要研究員會告訴他的&lt;/p&gt;

&lt;p&gt;研究生一樣），發明新的生物學方法或測量技術等等。正是通過加速整個研究過程，AI才能真正加速生物學。我想重申這一點，因為這是當我談論AI如何改變生物學時最常見的誤解：我不是在談論AI僅僅作為一種分析數據的工具。按照本文開頭的強大AI定義，我在談論使用AI來執行、指導並改進幾乎所有生物學家做的事情。&lt;/p&gt;

&lt;p&gt;—
為了具體說明我認為加速進展的可能性，生物學中相當大一部分的進步來自極少數的發現，通常與廣泛應用的測量工具或技術有關，這些技術允許我們在生物系統中進行精確但可程式化的干預。每年可能只有大約一項這樣的重大發現，但它們集體推動了生物學中50%以上的進展。這些發現之所以如此強大，正是因為它們能夠突破內在複雜性和數據限制，直接提高我們對生物過程的理解和控制能力。這些少數的發現，無論是在基礎科學理解還是醫療技術進步方面，都促成了我們在生物學領域的大部分進展。&lt;/p&gt;

&lt;p&gt;一些例子包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CRISPR&lt;/strong&gt;：這是一種允許在活體生物中編輯任何基因的技術（將任意基因序列替換為另一個序列）。自原始技術發展以來，已經不斷改進目標細胞類型的精確度、增加準確性並減少錯誤編輯，這些都是在人類中安全使用所需的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;各種顯微技術&lt;/strong&gt;：這些技術能夠在非常精確的層面上觀察正在發生的事情，包括高級光學顯微技術（具有各種螢光技術和特殊光學元件）、電子顯微鏡、原子力顯微鏡等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;基因測序與合成&lt;/strong&gt;：這些技術在過去幾十年裡，成本已經下降了好幾個數量級。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;光遺傳學技術&lt;/strong&gt;：這種技術允許我們通過照射光線來控制神經元的活動。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;mRNA疫苗&lt;/strong&gt;：理論上，這種技術使我們能夠設計針對任何疾病的疫苗，並能夠快速調整它們（mRNA疫苗在COVID期間變得廣為人知）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CAR-T細胞療法&lt;/strong&gt;：這是一種細胞療法，允許將免疫細胞從體內取出，並「重新編程」它們以攻擊某些目標，原則上它可以攻擊任何目標。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;概念性洞察&lt;/strong&gt;：例如，疾病的病菌理論或發現免疫系統與癌症之間的聯繫。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我列出這些技術的原因是為了提出一個關鍵主張：我認為，如果有更多有才華、創造力強的研究人員，這些技術的發現速度可能會提高10倍甚至更多。換句話說，我認為對這些發現的智力回報是非常高的，生物學和醫學中的大多數進展基本上都是基於這些發現。&lt;/p&gt;

&lt;p&gt;為什麼我這麼認為？因為當我們試圖確定「智力的回報」時，有一些問題的答案顯示出這些技術具有極高的智力回報。首先，這些發現通常是由極少數研究人員完成的，通常是相同的一些人，這表明技能而不是隨機搜索（後者可能暗示長時間的實驗是限制因素）。其次，這些發現往往「本可以更早被發現」：例如，CRISPR是一個自20世紀80年代就已知的細菌免疫系統的天然組件，但人們花了25年才意識到它可以被重新用於基因編輯。此外，這些發現經常因為科學界缺乏對某些有前途的研究方向的支持而推遲數年（例如，mRNA疫苗的發明者的經歷）。第三，成功的項目通常是簡陋的，或是在最初人們不認為有前途的情況下進行的，而不是通過大規模資金支持的計畫。這表明，不僅僅是大規模資源集中帶來了發現，還有創意的力量在起作用。&lt;/p&gt;

&lt;p&gt;最後，雖然這些發現中有些具有「連續依賴性」（你需要先做出發現A才能擁有做出發現B的工具或知識），這可能會造成實驗延遲，但許多，甚至可能是大多數的發現是獨立的，這意味著可以同時並行研究許多發現。這些事實，加上我個人在生物學領域的經驗，讓我強烈感覺到，如果科學家們能夠更聰明並且更善於利用人類積累的生物學知識，數百項這樣的發現等待著被揭示（再以CRISPR為例）。AlphaFold/AlphaProteo在解決重要問題上比人類有效得多，儘管人類已經設計了數十年的物理建模，這在某種程度上證明了這一點（儘管是在一個狹窄領域內的工具），這應該可以指引我們向前。&lt;/p&gt;

&lt;p&gt;因此，我猜測強大的AI至少可以將這些發現的速度提高10倍，使我們在5到10年內達到未來50至100年的生物學進展。為什麼不是100倍呢？也許這是可能的，但這裡的連續依賴性和實驗時間變得重要了：要在1年內取得100年的進展，需要很多事情第一次就做對，包括動物實驗以及設計顯微鏡或昂貴的實驗室設備等。我其實對於我們可能在5到10年內取得1000年的進展這個看法持開放態度，但我非常懷疑我們能在1年內完成100年的進展。另一種說法是，我認為存在不可避免的延遲：實驗和硬件設計有一定的「延遲」，需要在一定的次數上反覆進行，才能學到那些不能通過邏輯推理得出的東西。但是在這個基礎上，或許可以實現大規模並行。&lt;/p&gt;

&lt;h3 id=&quot;臨床試驗呢&quot;&gt;臨床試驗呢？&lt;/h3&gt;

&lt;p&gt;儘管臨床試驗有許多官僚障礙和緩慢進展的問題，但事實是，大部分（雖然不是全部）進展緩慢最終源於需要嚴格評估那些效果不佳或模糊的藥物。這不幸的是今天大多數療法的真相：平均的癌症藥物能延長生存期幾個月，但伴隨著需要仔細衡量的顯著副作用（阿茲海默症藥物也有類似情況）。這導致了龐大的研究（為了達到統計學的力量）和難以抉擇的權衡，這些權衡通常由於官僚主義或複雜的利益糾葛，使得監管機構難以做出正確的決策。&lt;/p&gt;

&lt;p&gt;當某些療法非常有效時，進展會快得多：有一條加速批准通道，當療效明顯時，審批的難度要小得多。例如，COVID期間的mRNA疫苗在9個月內獲得批准，比通常的進展速度要快得多。即便如此，即便在這些條件下，臨床試驗仍然太慢了——mRNA疫苗或許應該在大約2個月內獲得批准。但這些1年左右的延遲，與大規模並行處理的可能性相結合，再加上只需少量的試錯機會（「幾次嘗試」），與5到10年內的根本性轉變是完全相容的。更樂觀的是，AI支持的生物科學可能會通過開發更好的動物和細胞實驗模型（甚至模擬）來減少臨床試驗中的反覆試錯需求，這些模型更能準確預測在人體中會發生什麼。這對於發展針對老化過程的藥物尤為重要，因為老化過程需要數十年，且我們需要更快的迭代循環。&lt;/p&gt;

&lt;p&gt;最後，在臨床試驗和社會障礙的問題上，值得明確指出的是，從某些方面來看，生物醫學創新在實際應用中的成功記錄異常強大，這與其他技術形成了鮮明對比。&lt;/p&gt;

&lt;p&gt;總結以上內容，我的基本預測是，AI支持的生物學和&lt;/p&gt;

&lt;p&gt;醫學將使我們在5到10年內取得相當於人類生物學家在未來50到100年內所能取得的進展。我將此稱為「壓縮的21世紀」：即在強大的AI誕生後的數年內，我們將在生物學和醫學領域實現整個21世紀的進步。
—
當然，還有更多內容！讓我們繼續：&lt;/p&gt;

&lt;p&gt;雖然預測強大的AI在未來幾年內能做什麼仍然是困難和充滿推測性的，但問「人類在未來100年內能實現什麼？」這樣的具體問題會更具現實性。簡單看看我們在20世紀的成就，或推測21世紀的前20年，或者問「10個CRISPR和50個CAR-T療法」能帶來什麼，這些都為我們提供了實際、具體的方式來估計強大的AI可能帶來的進步。&lt;/p&gt;

&lt;p&gt;接下來我將試圖列出我們可能期望的進展清單。這並不是基於任何嚴謹的方法學，細節幾乎肯定會出錯，但它旨在表達我們應該期待的進步級別：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;可靠的傳染病預防與治療&lt;/strong&gt;。考慮到20世紀對傳染病的巨大進步，想像我們在「壓縮的21世紀」中可以「完成這一任務」並不算激進。mRNA疫苗和類似技術已經指向了「針對任何東西的疫苗」的方向。是否可以完全根除傳染病（而不僅僅是某些地方）取決於貧困和不平等等問題，這些問題在第三節中進行了討論。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;消除大多數癌症&lt;/strong&gt;。過去幾十年來，癌症的死亡率每年下降約2％；因此，按照目前的人類科學進展，我們正走在消除大多數癌症的道路上。一些亞型癌症已經基本治癒（例如，一些血癌類型使用CAR-T療法），我對那些能夠在癌症初期就精確靶向並防止其增長的選擇性藥物感到更加興奮。AI還將使針對個體基因組的個性化癌症治療變得可行，這在今天是可能的，但因為耗費大量時間和人力專業知識，成本非常高。95%以上的癌症死亡率和發病率減少似乎是可能的。儘管如此，癌症非常多樣且具有適應性，因此很可能仍然會有一系列罕見且難以治療的惡性腫瘤存在。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;有效的遺傳疾病預防與治療&lt;/strong&gt;。大幅改善的胚胎篩查技術可能使預防大多數遺傳病成為可能，並且某種更加安全、可靠的CRISPR後代技術可能治癒現有的遺傳病。然而，影響大部分細胞的全身性疾病可能是最後的頑疾。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;阿茲海默症的預防&lt;/strong&gt;。我們對阿茲海默症的病因一直難以確定（它與β-類澱粉蛋白有關，但具體細節似乎非常複雜）。這似乎正是可以通過更好的測量工具解決的問題，因此我對AI解決這個問題充滿信心。最終可能會通過一些相對簡單的干預措施來預防它，但目前存在的阿茲海默症損害可能很難逆轉。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;其他疾病的改善治療&lt;/strong&gt;。這是包括糖尿病、肥胖症、心臟病、自身免疫疾病等其他疾病的統稱。這些疾病大多比癌症和阿茲海默症「容易」解決，並且在許多情況下已經顯著減少。例如，心臟病的死亡率已經下降了50%以上，簡單的干預措施，如GLP-1激動劑，已經對肥胖和糖尿病取得了巨大進展。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;生物自由&lt;/strong&gt;。過去70年，生育控制、體重管理等方面的進展極大提高了人們對自己身體過程的控制能力。但我懷疑AI加速的生物學會大大擴展這一領域的可能性：體重、外貌、繁殖以及其他生物過程將完全由人們自行選擇。我們將此稱為「生物自由」：每個人應該有權選擇自己想要成為什麼樣的人，並以自己最喜歡的方式過生活。當然，全球平等的訪問權將是一個重要問題；參見第三節。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;人類壽命的倍增&lt;/strong&gt;。這可能聽起來很激進，但20世紀的預期壽命幾乎翻了一番（從大約40歲到大約75歲），所以「壓縮的21世紀」再翻一番達到150歲，這也是符合趨勢的。顯然，減緩衰老過程的干預措施將不同於上一世紀用來防止早逝（主要是兒童期死亡）的措施，但變革的規模並非史無前例。具體而言，已經存在能將大鼠最大壽命增加25%至50%的藥物，且副作用有限。而某些動物（例如某些種類的海龜）已經可以活到200年，所以顯然人類並沒有達到某種理論上的壽命上限。估計最重要的需求可能是可靠且不會被過度優化的老化生物標記，這將允許我們在實驗和臨床試驗中快速迭代。一旦人類壽命達到150歲，我們可能達到「逃逸速度」，這將使今天的大部分人可以活到自己想要的年齡，儘管這在生物學上並不保證是可能的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;反思這份清單時，若在未來7到12年內實現所有這些目標（這符合激進的AI時間表），這將會是一次無與倫比的人道主義勝利，將一舉消除困擾人類數千年的大部分災難。許多我的朋友和同事現在正在撫養孩子，當這些孩子長大時，我希望任何關於疾病的提及對他們來說就像我們今天聽到壞血病、天花或黑死病一樣陌生。這一代人將受益於更多的生物自由和自我表達運用，如果有幸，或許還能夠活到他們想要的年齡。&lt;/p&gt;

&lt;p&gt;即使生物學是唯一被AI加速的領域，世界的變化也將是巨大的。這些改變對於大多數人來說將是超出預期的，尤其是那些未曾預料到強大AI的人群。舉例來說，目前成千上萬的經濟學家和政策專家正在討論如何讓社會保障和醫療保險保持運作，並廣泛討論如何降低醫療成本（這些大部分由70歲以上的人群消耗，尤其是癌症等終末期疾病患者）。如果這些進展成真，這些問題將得到徹底改善，因為工作年齡與退休人口的比例將會顯著改變。毫無疑問，這些挑戰將被其他挑戰所取代，例如如何確保新技術的廣泛普及，但值得反思的是，即使僅僅是生物學領域的成功，也會給世界帶來多麼大的改變。&lt;/p&gt;

&lt;p&gt;—&lt;/p&gt;

&lt;h3 id=&quot;2-神經科學與心智&quot;&gt;2. 神經科學與心智&lt;/h3&gt;

&lt;p&gt;在前一節中，我主要討論了物理疾病和生物學，但還沒有涉及神經科學或心理健康。然而，神經科學是生物學的子學科，而心理健康與身體健康同樣重要。事實上，心理健康對人類幸福的影響甚至比身體健康更直接。數億人因為成癮、抑鬱、精神分裂症、自閉症、創傷後應激障礙（PTSD）、反社會人格障礙或智力障礙等問題，生活質量極低。還有數十億人面臨日常的心理問題，這些問題往往可以被看作是上述嚴重疾病的輕度版本。與一般的生物學一樣，AI不僅可以解決這些問題，還可能進一步提高人類的基本心理狀態。&lt;/p&gt;

&lt;p&gt;我在前一節中概述的基本框架同樣適用於神經科學。這個領域由少數與測量工具或精確干預有關的發現推動前進。在前面列舉的技術清單中，光遺傳學是一項神經科學的突破，最近的CLARITY和擴展顯微技術也是這一方向的進展，此外許多普通的細胞生物學方法也直接應用於神經科學。我認為這些進展的速度將被AI加速，因此「在5到10年內實現100年的進展」這個框架在神經科學領域應用起來也和生物學一樣合適，理由相同。與生物學一樣，20世紀神經科學的進步非常巨大——例如，我們直到1950年代才理解神經元是如何發放信號的。因此，預期AI加速的神經科學會在短短幾年內實現快速進步是合理的。&lt;/p&gt;

&lt;p&gt;我們還應該補充一點：過去幾年我們從AI本身學到的一些知識可能有助於推動神經科學的進步，即使這仍然主要由人類來完成。&lt;strong&gt;解釋性&lt;/strong&gt; 是一個明顯的例子：雖然生物神經元表面上與人工神經元的運作方式完全不同（它們通過脈衝進行通信，並且通常以脈衝速率進行，這意味著存在一個時間因素，而這在人工神經元中並不存在），但關於「如何讓一個由簡單單元組成的分布式網絡通過訓練來協作完成重要計算」這個基本問題是一樣的，我強烈懷疑在大多數有趣的計算問題中，神經元之間的通信細節將被抽象化。AI解釋性研究者發現的一些計算機制，最近也在小鼠的大腦中被重新發現。&lt;/p&gt;

&lt;p&gt;在人工神經網絡上做實驗比在真實的神經網絡上做實驗要容易得多（後者通常需要切開動物的大腦），因此解釋性可能會成為提高我們對神經科學理解的一種工具。此外，強大的AI本身可能比人類更有效地開發和應用這些工具。&lt;/p&gt;

&lt;p&gt;除了解釋性，AI在如何訓練智能系統方面所學到的知識應該（雖然我不確定它已經）推動神經科學的革命。在我研究神經科學時，許多人專注於一些我現在認為是錯誤的學習問題，因為當時並不存在「&lt;strong&gt;規模假說&lt;/strong&gt;」/「痛苦的教訓」。這一假設認為，簡單的目標函數加上大量的數據可以驅動非常複雜的行為，這使得了解目標函數和架構偏差變得更加有趣，而了解細節的計算則不那麼重要。我近年來沒有密切關注這個領域，但我模糊地感覺到，計算神經科學家仍然沒有完全吸收這一教訓。我的態度一直是「啊哈——這是一個高層次上解釋智能如何運作以及為什麼它如此容易演化的答案」，但我不認為這是大多數神經科學家的看法，部分原因是即使在AI領域內，規模假說作為「智能的秘密」也尚未被完全接受。&lt;/p&gt;

&lt;p&gt;我認為神經科學家應該努力將這一基本見解與人腦的特殊性（生物物理限制、進化歷史、拓撲結構、運動和感覺輸入/輸出等）結合起來，嘗試解決神經科學中的一些關鍵謎題。我相信有一些人正在這麼做，但還不夠，AI神經科學家將能夠更有效地利用這一角度來加速進展。&lt;/p&gt;

&lt;p&gt;我預計AI將通過四條不同的路徑來加速神經科學進步，這些路徑將一起努力治癒心理疾病並提高功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;傳統的分子生物學、化學和基因學&lt;/strong&gt;。這與第一節中的生物學故事基本相同，AI可能通過相同的機制加快這些領域的研究。有許多藥物可以調節神經遞質，以改變大腦功能、影響警覺性或感知、改變情緒等，AI可以幫助我們發明更多的藥物。AI也可能加速心理疾病的基因研究。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;精細的神經測量和干預&lt;/strong&gt;。這是指能夠測量大量個別神經元或神經回路的活動，並進行干預以改變其行為。光遺傳學和神經探針是能夠在活體有機體中進行測量和干預的技術，還有一些非常先進的方法（如分子計時器帶來的技術），原則上能夠記錄大量個別神經元的發放模式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;先進的計算神經科學&lt;/strong&gt;。如上所述，現代AI的具體見解和總體概念可能會對系統神經科學中的問題產生有益的應用，或許能揭示精神病或情緒障礙等複雜疾病的真實成因及動態。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;行為干預&lt;/strong&gt;。我沒有太多提到這一點，因為我們主要關注神經科學的生物學方面，但精神病學和心理學在20世紀發展了大量的行為干預措施；顯然，AI也可以加快這些方法的開發，並幫助患者遵循已有方法。更廣泛地說，「AI教練」這個概念也很有潛力——這種教練可以幫助你成為最好的自己，研究你的行為，幫助你學會更有效地生活。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我的猜測是，這四條進展路徑共同作用，就像處理身體疾病一樣，能在未來100年內治癒或預防大多數心理疾病，即使沒有AI的幫助——因此在AI的加速下，它們可能在5到10年內完成。具體而言，我猜測未來可能發生的事情包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;大多數心理疾病可以被治癒&lt;/strong&gt;。我不是精神疾病的專家（我在神經科學的時間主要是用來建立探針研究少量神經元），但我猜測像PTSD、抑鬱症、精神分裂症、成癮等疾病可能通過上述四個方向的結合被有效解決。答案可能是「某些生物化學方面出了問題」（雖然它可能非常複雜）和「神經網絡在高層次上出了問題」的結合。換句話說，這是一個系統神經科學問題——儘管這並不否認行為干預的重要性。測量和干預的工具，尤其是在活體人類中的工具，似乎可能帶來快速的迭代和進展。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;某些結構性問題可能更難解決，但不是不可能&lt;/strong&gt;。有證據表明，精神病與顯著的神經解剖學差異有關——例如，精神病患者的大腦某些區域可能明顯更小或發育不完全。精神病患者從年幼時就被認為缺乏同情心；不管他們的大腦&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有什麼不同，可能一開始就已經是這樣的。對於智力障礙和其他疾病，情況可能類似。重塑大腦聽起來很困難，但這似乎是一項具有高回報的智能挑戰。或許有某種方法可以將成人大腦引導至更早期或更具可塑性的狀態，使其能夠被重新塑形。我對這一點有很大的不確定性，但我對AI在這方面的發明能力持樂觀態度。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;有效的心理疾病基因預防似乎是可能的&lt;/strong&gt;。大多數心理疾病具有部分遺傳性，基因組廣泛關聯研究（GWAS）已經開始在識別相關因子方面取得進展，而這些因子往往數量眾多。預防這些疾病可能可以通過胚胎篩查來實現，這與物理疾病的故事相似。心理疾病的不同之處在於，這些疾病更有可能是多基因性的（即許多基因共同作用），因此由於其複雜性，無意中選擇掉與疾病相關的積極特徵的風險增加。然而，最近幾年，GWAS研究似乎表明這些關聯被過度誇大了。在任何情況下，AI加速的神經科學可能有助於我們弄清楚這些事情。當然，對於複雜特徵進行胚胎篩選會引發許多社會問題，並且可能引起爭議，儘管我猜測大多數人會支持篩選出嚴重或致殘的心理疾病。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;—&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;日常問題也將得到解決&lt;/strong&gt;。大多數人都有一些心理上的小問題，這些問題通常不被認為達到了臨床疾病的程度。一些人容易憤怒，另一些人難以集中注意力，或經常感到昏昏欲睡，有些人對變化過於恐懼或焦慮。今天，已經有一些藥物可以幫助改善警覺性或注意力（如咖啡因、莫達非尼、利他林），但就像其他領域一樣，未來可能有更多的選擇。可能還有許多尚未被發現的藥物存在，並且可能會有全新的干預模式，例如針對性光刺激（參見光遺傳學）或磁場。考慮到我們在20世紀開發出的調節認知功能和情緒狀態的藥物數量，我對「壓縮的21世紀」感到樂觀，在那裡每個人都可以讓自己的大腦表現得更好，並擁有更充實的日常生活體驗。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;人類的基礎生活體驗將變得更好&lt;/strong&gt;。再進一步，有許多人經歷過一些非凡的時刻，比如啟示、創造性靈感、慈悲、滿足、超越、愛、美或冥想中的平靜。這些經歷的性質和頻率因人而異，同一個人在不同時間內的體驗也會有很大差異，並且有時候這些經歷可能由某些藥物觸發（儘管通常伴隨著副作用）。所有這些都表明，「可能體驗的空間」非常廣泛，且人們一生中更大一部分時間可以由這些非凡的時刻所構成。也有可能進一步改善整體的認知功能。這或許是神經科學領域中的「生物自由」或「延長壽命」的對應概念。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在科幻小說中常常出現的一個話題是「心智上傳」，即捕捉人類大腦的模式和動態，並將其以軟件形式呈現。我並未在這裡討論這個話題，因為這本身就可以成為一篇獨立的文章。不過可以說，我認為心智上傳在原則上幾乎是可行的，但在實踐中，即便有了強大的AI，這仍然面臨著技術和社會的巨大挑戰，因此它可能超出了我們討論的5到10年的窗口期。&lt;/p&gt;

&lt;p&gt;總而言之，AI加速的神經科學可能極大地改善心理疾病的治療，甚至治癒大多數心理疾病，同時還會大大擴展人類的「認知和心理自由」，並提高認知和情緒能力。這將與前一節所描述的身體健康改善同樣具有顛覆性。或許外部世界不會有明顯的不同，但人類所經歷的世界將變得更加美好、更人道，並且提供更多自我實現的機會。我還懷疑，心理健康的改善將有助於解決許多看似政治或經濟的社會問題。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;3-經濟發展與貧困&quot;&gt;3. 經濟發展與貧困&lt;/h3&gt;

&lt;p&gt;前兩節主要討論了開發新技術來治療疾病並改善人類生活質量。然而，從人道主義的角度來看，顯然還有一個問題：「所有人都能享受到這些技術嗎？」&lt;/p&gt;

&lt;p&gt;開發一種治療疾病的方法是一回事，而徹底根除這種疾病又是另一回事。更廣泛地說，許多現有的健康干預措施尚未在世界各地得到應用，事實上，許多（非健康）技術進步也是如此。換句話說，世界上許多地區的生活標準仍然極為貧困：撒哈拉以南非洲的人均GDP約為2,000美元，而美國約為75,000美元。如果AI進一步提高了發達國家的經濟增長和生活質量，而幾乎沒有幫助發展中國家，那我們應該將此視為一個可怕的道德失敗，並視之為對前兩節中的人道主義勝利的一個污點。理想情況下，強大的AI應該幫助發展中國家追趕發達國家，即使它徹底改變了後者。&lt;/p&gt;

&lt;p&gt;我對AI解決不平等和促進經濟增長的信心，沒有像我相信它能發明根本性技術那麼強，因為技術顯然具有高回報的智慧（包括能夠繞過複雜性和數據缺乏），而經濟則涉及許多來自人類的限制，以及大量的內在複雜性。我對AI能解決著名的「社會主義計算問題」持懷疑態度，我也不認為各國政府會（或應該）將經濟政策交給AI，即便它能夠做到這一點。還有一些問題，比如如何說服人們接受有效的治療，而他們可能對此持懷疑態度。&lt;/p&gt;

&lt;p&gt;發展中國家面臨的挑戰因私人和公共部門中普遍存在的腐敗而更加複雜。腐敗創造了一個惡性循環：它加劇了貧困，而貧困又滋生更多的腐敗。AI驅動的經濟發展計劃需要考慮腐敗、薄弱的機構和其他非常「人類化」的挑戰。&lt;/p&gt;

&lt;p&gt;儘管如此，我還是看到了樂觀的理由。疾病已被根除，許多國家從貧窮走向富裕，這些任務中的決策明顯展示了高回報的智慧（儘管存在人類的限制和複雜性）。因此，AI可能比人類更好地完成這些任務。或許還有一些有針對性的干預措施，可以繞過人類的限制，這正是AI可以專注的地方。更重要的是，我們必須努力。AI公司和發達國家的政策制定者都需要盡自己的一份力量，確保發展中國家不被拋在後面；這是一項巨大的道德責任。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;在這一節中，我將繼續對未來5到10年內，當強大的AI出現時，發展中國家的情況做一些猜測：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;健康干預措施的分佈&lt;/strong&gt;。我對這個領域最為樂觀，因為健康干預措施已經在全球範圍內成功地被分佈：在20世紀70年代，天花被徹底消滅，現在小兒麻痺症和幾內亞蟲病的年發病率不到100例。數學上精密的流行病學建模在疾病根除運動中發揮了積極作用，很有可能AI系統可以比人類做得更好。分配後勤也可能得到極大的優化。我早期曾捐款給GiveWell（全球健康慈善評估機構），其中了解到一些健康慈善機構的效率遠高於其他機構；我們希望AI加速的努力可以變得更加有效。此外，一些生物學進展實際上使分配後勤更加簡單：例如，疟疾難以根除，因為每次感染後都需要治療；而僅需接種一次的疫苗使後勤簡化了許多（而這樣的疟疾疫苗實際上正在開發中）。甚至可能有更簡單的分配機制：例如，一些疾病可以通過針對動物攜帶者來根除，這原則上可以通過釋放攜帶阻止疾病傳播細菌的蚊子，或者使用基因驅動技術直接消滅蚊子來實現。這些措施只需一兩次集中行動，而不需要一場針對數百萬人的協調運動。總體而言，我認為5到10年內，AI驅動的健康福利能夠傳播到世界上最貧窮的國家，其中相當一部分（也許是50％）的健康利益將被普及。我們可以設定的目標是，強大的AI出現5到10年後，至少要使發展中國家比今天的發達國家更健康。實現這一目標當然需要全球健康、慈善、政治倡導等方面的巨大努力，這是AI開發者和政策制定者需要共同幫助完成的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;經濟增長&lt;/strong&gt;。發展中國家是否可以在短期內不僅在健康方面，還在經濟方面迅速趕上發達國家？有一些先例：20世紀末期的數十年，幾個東亞經濟體實現了持續的~10％年均實際GDP增長率，使其追趕上了發達國家。人類經濟規劃者做出了導致這一成功的決策，他們並不是直接控制整個經濟，而是通過拉動一些關鍵的杠桿（如出口導向的產業政策，並抵制依賴自然資源的誘惑）；「AI財政部長和中央銀行行長」有可能複製甚至超越這10％的成就。一個重要的問題是如何讓發展中國家的政府採用它們，同時尊重自決原則——有些政府可能很熱衷於此，但其他國家可能持懷疑態度。樂觀的一面是，許多上一條中提到的健康干預措施可能會自然而然地促進經濟增長：根除艾滋病、疟疾、寄生蟲病將對生產力產生變革性的影響，更不用說一些神經科學干預措施（如改善情緒和專注力）對發達國家和發展中國家同樣會帶來的經濟效益了。最後，AI加速的技術（如能源技術、運輸無人機、改進的建築材料、更高效的物流和分配等）可能會自然地滲透到全球；例如，即使沒有慈善努力，手機也迅速在撒哈拉以南非洲普及，這是通過市場機制實現的。負面的一面是，雖然AI和自動化有許多潛在的好處，但它們也為那些尚未實現工業化的國家帶來了挑戰。如何確保這些國家在自動化日益增加的時代仍然能夠發展和改善經濟，是經濟學家和政策制定者需要解決的重要挑戰。總的來說，一個夢想中的場景——或許是我們應該努力實現的目標——是發展中國家每年實現20％的GDP增長率，其中10％來自AI驅動的經濟決策，另10％來自AI加速技術的自然擴散，包括但不限於健康。如果實現了這一目標，撒哈拉以南非洲的GDP將在5到10年內達到中國當前的水平，而發展中國家的大部分地區將超過美國當前的GDP。再次強調，這是一個夢想中的場景，而不是自然發生的結果：這需要我們所有人共同努力才能使其更有可能實現。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;糧食安全&lt;/strong&gt;。20世紀，肥料、農藥、自動化和更高效的土地利用等技術大大提高了農作物的產量，拯救了數百萬人免於飢餓。基因工程目前正進一步改良許多作物。找到更多的方法來實現這一點——以及讓農業供應鏈更加高效——可能會帶來一場AI驅動的「第二次綠色革命」，幫助縮小發展中國家和發達國家之間的差距。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;應對氣候變化&lt;/strong&gt;。氣候變化在發展中國家感受到的影響將更加嚴重，並可能阻礙其發展。我們可以預期，AI將促進技術的改進，這些技術將減緩或阻止氣候變化，從大氣中移除碳、清潔能源技術到實驗室培育的肉類，這些都可能減少我們對高碳排放的工廠化養殖的依賴。當然，正如前面所討論的，技術並不是限制氣候變化進展的唯一因素——在人類社會中有許多其他重要因素。但有理由相信，AI增強的研究將使減緩氣候變化的成本和破壞性大大降低，從而使許多反對意見不再成立，並釋放發展中國家的經濟潛力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;國內的不平等&lt;/strong&gt;。我大部分的討論集中在全球範圍內的不平等（我認為這是不平等最重要的體現形式），但顯然不平等也存在於國內。隨著先進的健康干預措施，尤其是壽命的急劇延長或認知增強藥物的出現，確實有理由擔心這些技術可能「只屬於富人」。對於國內的不平等，我相對比較樂觀，尤其是在發達國家，這有兩個原因。首先，市場在發達國家運作得更好，市場通常擅長隨著時間的推移降低高價值技術的成本。其次，發達國家的政治機構對公民更具回應性，且擁有更高的國家能力來執行普遍訪問計劃——我預期公民會要求獲得這些徹底改善生活質量的技術。當然，這並不是預先註定會成功——在這裡，我們必須集體努力，確保一個公平的社會。此外，還存在財富不平等的問題（與獲得救命和改善生活技術的不平等不同），這似乎更難解決，這在第五節中會有討論。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;退出的問題&lt;/strong&gt;。無論是在發達國家還是發展中國家，都可能會有人拒絕接受AI帶來的好處（類似於反疫苗運動，或者更一般的盧德運動）。這可能最終導致一個不好的循環，讓那些最不善於做出良好決策的人選擇放棄那些能夠改善決策能力的技術，從而導致一個日益擴大的鴻溝，甚至創造出一個反烏托邦的底層階級（有研究人員認為這將削弱民主，這個話題我會在下一節進一步討論）。這會&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;再次在AI的積極進展中留下道德污點。解決這個問題很困難，我不認為強制人們是倫理上可行的，但至少我們可以努力提高人們的科學理解能力——也許AI本身可以幫助我們解決這個問題。一個希望的跡象是，歷史上的反技術運動多數雷聲大、雨點小：反對現代技術可能很流行，但最終大多數人還是會採用它，至少當這是個人選擇的時候。個人往往會採用大多數健康和消費技術，而真正受到阻礙的技術，如核能，通常是集體政治決策的結果。&lt;/p&gt;

&lt;p&gt;總體而言，我對迅速將AI的生物學進展帶到發展中國家持樂觀態度。我對AI能夠實現前所未有的經濟增長並使發展中國家至少超越當前的發達國家感到有希望，但不確定性仍然存在。我對發達和發展中國家的「退出」問題感到擔憂，但我懷疑這個問題會隨著時間的推移逐漸消退，且AI可以幫助加速這一過程。這不會是一個完美的世界，那些落後的人不會在頭幾年完全趕上，但只要我們努力推動事情朝著正確的方向發展，速度可能會非常快。如果我們能做到這一點，我們可以為人類尊嚴和平等的承諾償付一部分賬單。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;4-和平與治理&quot;&gt;4. 和平與治理&lt;/h3&gt;

&lt;p&gt;假設前三節的內容都順利實現：疾病、貧困和不平等大幅減少，人類的生活質量顯著提高。然而，這並不意味著所有主要的人類苦難問題都得到了完全解決。人類依然對彼此構成威脅。雖然技術進步和經濟發展趨向於推動民主和和平，但這一趨勢非常鬆散，且常有（且最近也發生過）倒退。20世紀初，人們以為戰爭已經過去；但隨後兩次世界大戰爆發。三十年前，法蘭西斯·福山寫下《歷史的終結》，討論自由民主的最終勝利；但這並沒有如願發生。二十年前，美國政策制定者相信，與中國的自由貿易將導致中國隨著富裕的增長而變得更加自由；但事實上，我們現在似乎正朝著與新興的威權集團爆發第二次冷戰邁進。更有說服力的理論表明，互聯網技術實際上可能更有利於威權主義，而不是最初所相信的促進民主（如「阿拉伯之春」期間的情況）。因此，理解強大的AI將如何與這些有關和平、民主和自由的問題交織在一起，顯得尤為重要。&lt;/p&gt;

&lt;p&gt;不幸的是，我沒有足夠的理由相信AI會優先或結構性地促進民主與和平，像我相信它會促進人類健康並減輕貧困那樣明確。人類衝突具有對抗性，AI原則上可以幫助「好人」和「壞人」。更糟糕的是，AI似乎可能會促進更有效的宣傳和監控，而這恰恰是獨裁者的兩大工具。因此，作為個體，我們必須傾向於正確的方向：如果我們希望AI有利於民主和個人權利，我們就必須為此而奮鬥。我對此的看法比對國際不平等問題更加強烈：自由民主的勝利和政治穩定並非天生註定，也許甚至不是大概率事件，這將需要我們付出巨大的犧牲和努力，正如歷史上經常發生的那樣。&lt;/p&gt;

&lt;p&gt;我將這個問題分為兩個部分：國際衝突以及各國內部的結構。在國際層面，當強大的AI被創造出來時，民主國家在世界舞台上佔據上風似乎非常重要。AI驅動的威權主義過於可怕，不敢想像，因此民主國家需要能夠設定強大AI進入世界的條件，既避免被威權主義國家擊敗，也防止在威權國家內部出現侵犯人權的情況。&lt;/p&gt;

&lt;p&gt;我目前猜測，最好的方法是採取「協約策略」（entente strategy），即民主國家組成聯盟，試圖通過控制AI的供應鏈、快速擴展AI技術，並阻止或推遲對手獲取關鍵資源（如芯片和半導體設備），來在強大AI的發展上取得明顯優勢（即便只是一個暫時的優勢）。該聯盟一方面利用AI取得穩固的軍事優勢（「大棒」），另一方面則向越來越多的國家提供AI的好處（「胡蘿蔔」），以換取這些國家支持推動民主的策略（這有點類似於「和平原子」計劃）。這個聯盟的目標是獲得越來越多國家的支持，孤立我們的最壞對手，最終使他們處於一個不得不接受與世界其他國家相同條件的境地：放棄與民主國家的競爭，以獲得所有好處，且不與一個更強大的敵人對抗。&lt;/p&gt;

&lt;p&gt;如果我們能做到這一點，世界將由民主國家主導，這些國家擁有經濟和軍事實力，足以避免被威權國家破壞、征服或破壞，並可能將AI優勢轉化為持久的優勢。樂觀地說，這可能會實現一個「永恆的1991年」——即一個民主國家佔上風的世界，福山的夢想成真。當然，要達成這一目標將非常困難，特別是需要私營AI公司與民主政府之間的緊密合作，以及在胡蘿蔔與大棒之間做出極為明智的決策。&lt;/p&gt;

&lt;p&gt;即便這一切都進展順利，仍然要面對國內民主與威權主義之間的鬥爭問題。預測這方面的情況顯然非常困難，但我對全球環境下，如果民主國家控制最強大的AI，AI可能實際上在結構上有利於民主抱有一定樂觀態度。具體而言，在這種環境下，民主政府可以利用其優越的AI在信息戰中取勝：他們可以反制威權國家的影響和宣傳活動，甚至有可能創造一個全球自由的信息環境，威權國家無法在技術上封鎖或監控。也許不需要傳播宣傳，只要能夠反制惡意攻擊，並保障信息自由流通就足夠了。雖然這不是立即可見的，但這種平等的競爭環境有很大機會逐漸將全球治理推向民主化。&lt;/p&gt;

&lt;p&gt;首先，第一到第三節中提到的生活質量提升應該，總的來說，推動民主化：歷史上至少在一定程度上是這樣的。尤其是我認為心理健康、幸福感和教育的改善將促進民主，因為這三者都與支持威權領導人呈負相關。一般而言，當人們的其他需求得到滿足時，他們會更希望進行自我表達，而民主正是自我表達的一種形式。相反，威權主義依靠恐懼和怨恨而滋生。&lt;/p&gt;

&lt;p&gt;其次，免費的信息的確有很大可能削弱威權主義，只要威權國家無法審查這些信息。而且，無法審查的AI也能為個人提供強大的工具來削弱壓制性政府。壓制性政府靠的是剝奪人們的某種共同認知，讓他們無法意識到「皇帝沒有穿衣服」。例如，Srđa Popović 幫助推翻了塞爾維亞的米洛舍維奇政權，他曾經撰寫大量文章，討論如何通過心理戰術奪走獨裁者的權力，揭穿幻象，並動員起對抗獨裁者的支持。在每個人手中都擁有一個超級有效的AI版Popović（他的技能顯然具有高度的智慧回報），而獨裁者卻無法封鎖或審查，這可能會為全球的異見人士和改革者提供支持。再次強調，這將是一場漫長且艱苦的鬥爭，勝利並不保證，但如果我們以正確的方式設計和建設AI，那麼這至少是一場自由倡導者有機會佔優勢的戰鬥。&lt;/p&gt;

&lt;p&gt;就像我們對神經科學和生物學的預測一樣，我們還可以問一個問題：不僅僅是如何避免威權主義，我們還能如何使現有的民主變得更好？即使在民主國家內，社會不公也隨處可見。法治社會向公民作出承諾，人人都應該在法律面前平等，人人都有權利享有基本人權，但顯然，這些承諾在實踐中並非總能兌現。即便部分兌現了，我們仍應為之感到驕傲，但AI是否能幫助我們做得更好呢？&lt;/p&gt;

&lt;p&gt;例如，AI能否通過使決策和流程更加公正，來改善我們的法律和司法系統？目前，人們最擔心的是AI系統在法律或司法背景下可能成為歧視的源頭，這些擔憂確實很重要，必須加以防範。但同時，民主的活力也取決於如何利用新技術來改善民主機構，而不僅&lt;/p&gt;

&lt;p&gt;僅是應對風險。一個真正成熟且成功的AI實施方案，可能具有減少偏見並對每個人都更加公平的潛力。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;法律系統的挑戰&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;幾個世紀以來，法律系統一直面臨著一個兩難境地：法律的目標是公正的，但由於本質上的主觀性，它必須由帶有偏見的人類來解釋。嘗試讓法律完全機械化的努力並未奏效，因為現實世界過於複雜，無法完全以數學公式來捕捉。因此，法律系統依賴於一些不精確的標準，如「殘忍且不尋常的懲罰」或「完全沒有補償性的社會意義」，然後由人類來進行解釋，這通常會顯示出偏見、偏袒或隨意性。加密貨幣中的「智能合約」並未革命性地改變法律，因為普通的代碼還不足以處理許多重要的事務。然而，AI可能足夠聰明，能在更廣泛和模糊的判斷上進行可重複且機械化的操作。&lt;/p&gt;

&lt;p&gt;我並不是在建議用AI系統取代法官，但結合公正性與理解和處理真實世界複雜情況的能力，似乎應該在法律和正義中有其積極的應用。至少，這樣的系統可以作為人類的輔助手段，在決策過程中提供幫助。任何這樣的系統都需要透明度，而一門成熟的AI科學可以提供這種透明度：可以對系統的訓練過程進行廣泛的研究，並使用先進的可解釋性技術來檢視最終模型，並評估其是否存在隱性偏見，這是人類無法做到的。這樣的AI工具還可以用來監控司法或警察環境中的基本權利侵犯行為，使憲法更加自我執行。&lt;/p&gt;

&lt;p&gt;在類似的脈絡中，AI還可以用來匯集意見並驅動公民之間的共識，解決衝突，尋找共同點，並促進妥協。計算民主項目已經在這個方向上進行了一些早期的探索，其中包括與我的公司Anthropic的合作。更具知識性和深思熟慮的公民顯然會加強民主機構。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;政府服務的改善&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;還有一個明顯的機會是使用AI來幫助提供政府服務——例如，健康福利或社會服務，這些在原則上應該人人都能享有，但實際上在許多地方往往缺乏，且差異很大。這包括醫療服務、車管所（DMV）、稅務、社會保障、建築法規執行等。擁有一個非常周到且知識豐富的AI，其工作是幫助你獲得政府承諾的所有合法權利，並幫助你遵守經常令人困惑的政府規定，這將是一件大事。提高國家的執行能力既有助於實現法律面前的平等承諾，也增強了對民主治理的尊重。服務的拙劣執行是目前對政府持懷疑態度的重要驅動因素。&lt;/p&gt;

&lt;p&gt;所有這些都是一些比較模糊的想法，正如我在本節開頭所說，我對這些想法的可行性並不像我對生物學、神經科學和減少貧困的進步那樣充滿信心。這些構想可能過於理想化。然而，重要的是要擁有一個雄心勃勃的願景，願意大膽夢想並嘗試新事物。AI作為自由、個人權利和法律平等的捍衛者，這一願景過於強大，不應輕易放棄。21世紀的AI技術可以打造一個既能更強力保護個人自由的國度，又成為全世界推崇自由民主政府的燈塔。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;5-工作與意義&quot;&gt;5. 工作與意義&lt;/h3&gt;

&lt;p&gt;即使前四節所述的一切都順利實現——我們不僅減輕了疾病、貧困和不平等，自由民主成為了主導的治理形式，並且現有的自由民主國家變得比以前更好——仍然有一個重要的問題存在：「雖然我們生活在這樣一個技術先進且公平的世界中，但當AI接管了所有事情時，人類如何找到意義？更不用說，人類該如何在經濟上生存？」&lt;/p&gt;

&lt;p&gt;我認為這個問題比其他問題更難處理。我並不是說我對這個問題比對其他問題更加悲觀（儘管我確實看到了挑戰）。我指的是這個問題更加模糊，且難以提前預測，因為它涉及社會如何組織的大範圍問題，而這些問題往往是隨著時間和去中心化的方式自我解決的。例如，歷史上的狩獵採集社會可能認為，沒有狩獵和與狩獵相關的宗教儀式，生活就毫無意義；他們可能還無法理解我們如何維持一個養活所有人的經濟，或者如何在一個機械化的社會中找到人們可以發揮的作用。&lt;/p&gt;

&lt;p&gt;儘管如此，值得針對這個問題說幾句話，同時保持謹慎，因為這一節的篇幅短並不代表我不重視這些問題——恰恰相反，這反映了缺乏明確的答案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;關於意義的問題&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，我認為認為某項任務因為AI可以做得更好而變得毫無意義，這是個錯誤的觀點。大多數人並不是世界上最擅長做某件事的人，這並不影響他們對意義的追求。當然，今天人們仍然可以通過比較優勢來貢獻力量，並從他們產生的經濟價值中找到意義，但人們也樂於從事不產生經濟價值的活動。我經常玩視頻遊戲、游泳、在戶外散步、與朋友交談，這些活動都不產生任何經濟價值。我可能花一天時間嘗試提高我的遊戲技巧，或騎自行車爬山的速度，並且不在乎有人能做得比我好。在任何情況下，我認為意義主要來自於人際關係和聯繫，而不是來自於經濟勞動。人們確實渴望成就感，甚至是競爭感，並且在AI世界裡，依然可以像今天一樣花多年時間挑戰一項非常困難的任務，採用複雜的策略，類似於人們今天進行研究項目、嘗試成為好萊塢明星或創辦公司的方式。事實上，（a）某處的AI可以原則上比你做得更好，或（b）這項任務不再是全球經濟中受到經濟獎勵的部分，這兩者對我來說似乎並不重要。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;經濟挑戰&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;經濟問題對我來說實際上比意義問題更具挑戰性。這裡的「經濟」指的是這樣一個問題：當AI接管了足夠多的經濟活動後，大多數或所有人類可能無法在一個高度發達的AI驅動經濟中作出有意義的貢獻。這是一個比單純的不平等問題更大的宏觀問題，尤其是不平等於技術獲取方面的問題，我在第三節中討論過。&lt;/p&gt;

&lt;p&gt;首先，在短期內，我同意這樣的觀點：比較優勢將繼續使人類保持相關性，甚至可能增加他們的生產力，並在某些方面使人類之間的競爭更公平。只要AI只比人類在某些工作上好90%，那麼剩下的10%將使人類成為高度杠桿化的因素，從而提高報酬，甚至創造許多新的工作，這些工作可以補充並放大AI擅長的部分，擴展這個「10%」來繼續雇用幾乎所有人。事實上，即使AI能比人類在100%的事情上做得更好，只要它在某些任務上的效率較低或成本較高，或者人類和AI所使用的資源輸入有實質性差異，則比較優勢的邏輯仍然適用。人類在物理世界中可能在很長一段時間內保持相對優勢（甚至是絕對優勢）。因此，我認為，即使到了「數據中心裡的天才國度」，人類經濟也仍然能夠保持一定的合理性。&lt;/p&gt;

&lt;p&gt;然而，我確實認為，從長遠來看，AI將變得如此廣泛有效且成本低廉，以至於這種比較優勢將不再適用。屆時，我們當前的經濟體系將不再有意義，我們將需要進行更廣泛的社會對話，討論經濟應該如何組織。&lt;/p&gt;

&lt;p&gt;這可能聽起來很瘋狂，但事實上，人類文明過去已經成功地應對了幾次重大經濟轉型：從狩獵採集轉向農業，從農業轉向封建制度，再從封建制度轉向工業化。我懷疑將來會需要一些新的、更奇特的東西，而這是我們今天無法清晰預見的。也許它會像大規模的全民基本收入那麼簡單，雖然我懷疑這只是解決方案的一部分。也許是AI資本主義經濟，AI系統創造資源（資源數量將會非常巨大，因為總體經濟蛋糕將非常龐大），並基於某些源於人類價值的判斷，將資源分配給人類。也許經濟會依賴於類似「Whuffie分數」的系統。或者也許人類依然能夠在某些出乎我們預料的方式中，在這種新的經濟模式中保持經濟價值。所有這些解決方案都有其可能的問題，而在沒有大量迭代和實驗的情況下，無法確定它們是否會有效。而且，與其他挑戰一樣，我們需要努力爭取良好的結果：明顯存在著剝削或反烏托邦的潛在方向，我們必須努力避免。關於這些問題，還可以寫出更多的內容，我希望未來能有機會進一步討論。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;總結&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通過以上各個主題，我試圖描繪出一個既有可能實現、又遠優於當今世界的未來願景。我不確定這個世界是否真實可行，即便如此，沒有勇敢而堅定的人們付出巨大的努力和奮鬥，也不會自動達成。每個人（包括AI公司）都必須盡自己的一份力量，既要防範風險，也要充分實現AI的潛在好處。&lt;/p&gt;

&lt;p&gt;但這是一個值得為之奮鬥的世界。如果未來5到10年內，一切真的發生了——戰勝了大部分疾病，人類的生物和認知自由得以增長，數十億人擺脫了貧困，享有新技術，自由民主和人權得到新的復興——我相信所有目睹這一切的人都會感到難以言喻的震撼。我並不僅僅指個人從這些新技術中獲益的經歷，儘管這肯定會是令人驚嘆的。我指的是看到長久以來持有的一套理想突然同時實現的那一刻。我想許多人會因為這個世界的轉變而感動落淚。&lt;/p&gt;

&lt;p&gt;在寫這篇文章的過程中，我發現了一個有趣的矛盾。一方面，這裡所描繪的願景極其激進：這不是大多數人對於未來十年的預期，並且很可能會被許多人認為是荒誕的幻想。有些人甚至可能不認為這是理想的世界，因為這體現了某些價值觀和政治選擇，並不是每個人都會認同的。但是&lt;/p&gt;

&lt;p&gt;，另一方面，這個願景又顯得那麼理所當然——就像多次嘗試設想美好世界的結果不可避免地指向這個方向。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;當主角（來自一個名為「文化」的社會，其價值觀與我在這裡所描述的相似）前往一個壓迫、軍國主義的帝國時，該帝國的領導者是通過在一個複雜的戰爭遊戲中競爭來選出的。然而，這個遊戲複雜到足以讓玩家的戰略反映他們的政治和哲學觀點。主角成功擊敗了皇帝，證明了他的價值觀（即「文化」的價值觀）即使在一個由殘酷競爭和適者生存的社會設計的遊戲中，仍然是「贏家」的策略。Scott Alexander的一篇著名文章也有相似的論點——競爭最終會自我失敗，最終導致一個基於同情心和合作的社會。「道德宇宙的弧線」也是一個類似的概念。&lt;/p&gt;

&lt;p&gt;我認為「文化」的價值觀是一個「贏家」的策略，因為它們是數百萬個有著明確道德力量的小決策的總和，這些決策往往會將所有人聚集在一起走向同一個方向。基本的人類直覺，如公平、合作、好奇心和自主權，很難被駁斥，而且這些價值觀是累積的，與我們更具破壞性的衝動不同，後者往往沒有這種持久性。很容易論證：如果我們能防止，孩子們就不應該死於疾病，從這裡也很容易推論出所有人的孩子都應該享有同等的權利。從這裡，我們很容易得出結論：我們應該團結起來，運用我們的智慧來實現這個結果。幾乎沒有人會反對應該懲罰那些不必要地攻擊或傷害他人的人，從這裡不難延伸到應該對所有人一致且系統地進行懲罰的想法。同樣，直覺上也認為，人們應該有自主權和對自己生活的責任。這些簡單的直覺，如果被邏輯地推到極致，最終會引向法治、民主和啟蒙價值觀。如果這不是必然的結果，那至少是一個統計趨勢，這是人類早已走向的方向。AI只不過提供了一個加速我們到達這個目的地的機會——讓邏輯更加清晰，讓目標更加明確。&lt;/p&gt;

&lt;p&gt;然而，這是一件超越尋常的美妙之事。我們有機會在實現這個願景的過程中扮演一個小小的角色。&lt;/p&gt;

&lt;hr /&gt;</content><author><name>Marvin</name></author><category term="programming" /><category term="AI" /><category term="Claude" /><summary type="html">TL;DR 強大AI 如何讓世界變得更美好：五大領域的潛在益處</summary></entry><entry xml:lang="zh"><title type="html">使用 DispatchWorkItem 設定特定時間的 API 任務</title><link href="http://localhost:4000/zh/swift/using-DispatchWorkItem-set-specific-timeout-api-task/" rel="alternate" type="text/html" title="使用 DispatchWorkItem 設定特定時間的 API 任務" /><published>2024-09-22T17:00:00+08:00</published><updated>2024-09-22T17:00:00+08:00</updated><id>http://localhost:4000/zh/swift/using-DispatchWorkItem-set-specific-timeout-api-task</id><content type="html" xml:base="http://localhost:4000/zh/swift/using-DispatchWorkItem-set-specific-timeout-api-task/">&lt;p&gt;情境假設: 你正在開發一個電子商務的 iOS 應用。這個應用有多個功能，包括瀏覽商品、添加到購物車、查看庫存、下單等。其中，實時庫存查詢功能特別關鍵，因為它直接影響用戶的購買決策和體驗。&lt;/p&gt;

&lt;h2 id=&quot;特殊需求&quot;&gt;特殊需求：&lt;/h2&gt;
&lt;p&gt;在這個應用中，大多數 API 請求都使用標準的網絡超時設置（比如 30 秒或 60 秒）。但是，庫存查詢 API 有一個特殊要求：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;嚴格的超時限制：如果庫存查詢 API 在 5 秒內沒有返回結果，應用就必須將其視為錯誤。&lt;/li&gt;
  &lt;li&gt;用戶體驗考慮：這個嚴格的超時限制是為了確保用戶能夠快速獲得庫存信息。如果查詢時間過長，用戶可能會認為應用無響應或放棄購買。&lt;/li&gt;
  &lt;li&gt;系統負載考慮：在高峰期，大量並發的長時間庫存查詢可能會對後端系統造成壓力。通過限制查詢時間，可以減輕服務器負擔。&lt;/li&gt;
  &lt;li&gt;特殊錯誤處理：當發生 5 秒超時時，應用需要向用戶顯示一個特定的錯誤消息，例如「庫存信息暫時無法獲取，請稍後再試」，而不是通用的網絡錯誤消息。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中，第 1 項和第 4 項的規格和 iOS 前端有關，但！也只有這一道 api 有這個需求，我們並不希望為了這個需求，而修改所有 api 的實作。&lt;/p&gt;

&lt;p&gt;我們可以透過 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchWorkItem&lt;/code&gt; 來設定特定時間的 API 任務，並在任務完成後，透過 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchQueue.main.async&lt;/code&gt; 來執行我們的程式碼。&lt;/p&gt;

&lt;h2 id=&quot;解法比較使用-dispatchworkitem-vs-單純使用-flag-的-truefalse-來控制&quot;&gt;解法比較，使用 DispatchWorkItem vs. 單純使用 flag 的 true/false 來控制&lt;/h2&gt;

&lt;p&gt;使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchWorkItem&lt;/code&gt; 相比使用 flag 來實現超時控制確實有一些優勢。讓我們來比較一下這兩種方法：&lt;/p&gt;

&lt;h3 id=&quot;使用-dispatchworkitem-的優勢&quot;&gt;使用 DispatchWorkItem 的優勢：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;清晰的代碼結構&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchWorkItem&lt;/code&gt; 提供了一個封裝任務的清晰方式，使代碼更易讀和維護。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;內建的取消機制&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchWorkItem&lt;/code&gt; 有內建的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cancel()&lt;/code&gt; 方法，可以輕鬆取消尚未執行的任務。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;更精確的時間控制&lt;/strong&gt;：使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchQueue.asyncAfter&lt;/code&gt; 配合 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchWorkItem&lt;/code&gt;，可以更精確地控制超時時間。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;更好的資源管理&lt;/strong&gt;：當 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchWorkItem&lt;/code&gt; 被取消或完成時，系統會自動處理相關資源的釋放。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;使用-dispatchworkitem-設定特定時間的-api-任務&quot;&gt;使用 DispatchWorkItem 設定特定時間的 API 任務&lt;/h2&gt;

&lt;p&gt;以下是還沒有加上 5 秒超時限制的 api 任務實作：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;postData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Encodable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Decodable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;POST&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;application/json&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;forHTTPHeaderField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpBody&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONEncoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;DispatchQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;kt&quot;&gt;URLSession&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dataTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;DispatchQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                
                &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;NSError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;domain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;APIManager&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;NSLocalizedDescriptionKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;No data received&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])))&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                
                &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;decodedData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONDecoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decodedData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;加上-5-秒超時限制&quot;&gt;加上 5 秒超時限制&lt;/h3&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;postData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Encodable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Decodable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;@escaping&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;POST&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;application/json&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;forHTTPHeaderField&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpBody&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONEncoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;DispatchQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 設定 5 秒超時限制 設定 workitem&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;timeoutWorkItem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;DispatchWorkItem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;DispatchQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;NSError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;domain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;timeout&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;NSLocalizedDescriptionKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;timed out&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 設定 5 秒超時限制 設定&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;DispatchQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asyncAfter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;deadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeoutWorkItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;URLSession&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dataTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 如果 request 在 5 秒內完成，取消 timeoutWorkItem&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;timeoutWorkItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        
        &lt;span class=&quot;kt&quot;&gt;DispatchQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            
            &lt;span class=&quot;k&quot;&gt;guard&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;NSError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;domain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;APIManager&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;userInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;NSLocalizedDescriptionKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;No data received&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])))&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            
            &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;decodedData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;JSONDecoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decodedData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;failure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Marvin Lin</name></author><category term="swift" /><category term="Xcode" /><category term="Swift" /><summary type="html">情境假設: 你正在開發一個電子商務的 iOS 應用。這個應用有多個功能，包括瀏覽商品、添加到購物車、查看庫存、下單等。其中，實時庫存查詢功能特別關鍵，因為它直接影響用戶的購買決策和體驗。</summary></entry><entry xml:lang="zh"><title type="html">Xcode 16 Release Notes 新功能 機翻</title><link href="http://localhost:4000/zh/swift/xcode16-release-notes-whats-new/" rel="alternate" type="text/html" title="Xcode 16 Release Notes 新功能 機翻" /><published>2024-09-22T16:03:00+08:00</published><updated>2024-09-22T16:03:00+08:00</updated><id>http://localhost:4000/zh/swift/xcode16-release-notes-whats-new</id><content type="html" xml:base="http://localhost:4000/zh/swift/xcode16-release-notes-whats-new/">&lt;p&gt;這份 Xcode 16 的 Release Notes 中有以下新增功能（New Features）：&lt;/p&gt;

&lt;h3 id=&quot;general&quot;&gt;General&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;預測代碼完成&lt;/strong&gt;（Predictive Code Completion）：Xcode 16 現在支援在所有 Apple silicon Mac 上進行預測代碼完成。這功能透過專為 Swift 和 Apple SDK 訓練的機器學習模型驅動，需在 macOS 15 或更新的系統上運行。（116310768）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;build-settings&quot;&gt;Build Settings&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;從構建設置編輯器複製和貼上&lt;/strong&gt;：現在使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.xcconfig&lt;/code&gt; 檔案語法。（14333348）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;項目導航的“以…方式開啟”上下文菜單&lt;/strong&gt;：現在支援為每個檔案類型選擇預設編輯器。（24666459）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;xcodebuild&quot;&gt;xcodebuild&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;匯入和匯出下載的平台&lt;/strong&gt;：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xcodebuild&lt;/code&gt; 現在支援匯入和匯出下載的平臺到磁碟。這可用於將模擬器磁碟映像匯出到其他需要該模擬器運行時的機器上，無需重新下載。（129189162）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;reality-composer-pro&quot;&gt;Reality Composer Pro&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;時間軸&lt;/strong&gt;：可以序列化執行動作，並根據觸發條件啟動時間軸。（75589529）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;虛擬環境探測元件&lt;/strong&gt;：可以控制虛擬環境的照明效果。（117770245）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;碼位支持&lt;/strong&gt;：支持控制音頻屬性及擴展至8個紋理座標。（123364636）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;previews&quot;&gt;Previews&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;共享構建產物&lt;/strong&gt;：新的預覽引擎支持在 Build and Run 與 Previews 之間共享構建產物。（37353090）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Previewable&lt;/code&gt; 宏&lt;/strong&gt;：允許在預覽中直接使用 SwiftUI 的 property wrapper，無需定義中介包裝視圖。（110570957）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;storekit&quot;&gt;StoreKit&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;隱私協議&lt;/strong&gt;：可以在 StoreKit 配置中設置測試用的隱私政策及訂閱協議。（114228169）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;swift&quot;&gt;Swift&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Swift 支持非複製的 C++ 類型&lt;/strong&gt;：允許在 Swift 中使用不需要複製的 C++ 類型。（83358475）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~Copyable&lt;/code&gt; 修飾符&lt;/strong&gt;：可用於 protocols 和泛型參數來禁止複製。（101653009）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;函數型別中的錯誤類型&lt;/strong&gt;：可以在函數簽名中指定錯誤類型，支援更精確的錯誤傳播。（125992062）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;test-plans&quot;&gt;Test Plans&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;測試報告中支持 Swift Testing 框架&lt;/strong&gt;：測試報告現在顯示 Swift Testing 框架的元數據標籤，以及按測試執行狀態進行篩選的功能。（127015832）&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Marvin Lin</name></author><category term="swift" /><category term="Xcode" /><category term="Swift" /><summary type="html">這份 Xcode 16 的 Release Notes 中有以下新增功能（New Features）：</summary></entry><entry xml:lang="en"><title type="html">Xcode 16 Release Notes, new features</title><link href="http://localhost:4000/en/swift/xcode16-release-notes-whats-new/" rel="alternate" type="text/html" title="Xcode 16 Release Notes, new features" /><published>2024-09-22T16:03:00+08:00</published><updated>2024-09-22T16:03:00+08:00</updated><id>http://localhost:4000/en/swift/xcode16-release-notes-whats-new</id><content type="html" xml:base="http://localhost:4000/en/swift/xcode16-release-notes-whats-new/">&lt;p&gt;Here are the &lt;strong&gt;New Features&lt;/strong&gt; from the Xcode 16 release notes:&lt;/p&gt;

&lt;h3 id=&quot;general&quot;&gt;General&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Predictive Code Completion&lt;/strong&gt; is now supported on all Apple silicon Macs. It uses a machine learning model specifically trained for Swift and Apple SDKs. (116310768)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;build-settings&quot;&gt;Build Settings&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Copy and paste from the build settings editor&lt;/strong&gt; now uses xcconfig file syntax. (14333348)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The Project Navigator’s “Open As” context menu&lt;/strong&gt; now supports choosing default editors per file type. (24666459)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;xcodebuild&quot;&gt;xcodebuild&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;xcodebuild supports importing and exporting a downloaded platform&lt;/strong&gt; to disk. This allows simulator disk images to be exported and applied to other Xcode installations without redownloading. (129189162)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;reality-composer-pro&quot;&gt;Reality Composer Pro&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Timelines&lt;/strong&gt; allow you to sequence actions to be executed in a particular order or time. (75589529)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;VirtualEnvironmentProbeComponent&lt;/strong&gt; enables control of the lighting of virtual environments. (117770245)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Extended texcoords&lt;/strong&gt; from 2 to 8 buffers, allowing for more complex data types. (123364636)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;previews&quot;&gt;Previews&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;New Preview Execution Engine&lt;/strong&gt; supports shared build products between Build and Run and Previews for faster switching. (37353090)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;@Previewable macro&lt;/strong&gt; allows direct use of property wrappers like @State in Previews without needing an intermediate wrapper view. (110570957)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;storekit&quot;&gt;StoreKit&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Privacy manifests&lt;/strong&gt; can now be included as copied resources in StoreKit configurations for testing privacy policies and terms of service in SubscriptionStoreView. (114228169)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;swift&quot;&gt;Swift&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Swift now supports non-copyable C++ types&lt;/strong&gt; when interacting with C++ code from Swift. (83358475)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;~Copyable modifier&lt;/strong&gt; can now be used to suppress copyability on protocols and generic parameters. (101653009)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Typed throws&lt;/strong&gt; allows functions to specify the exact type of error they throw. (125992062)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;test-plans&quot;&gt;Test Plans&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Test reports now support Swift Testing framework&lt;/strong&gt; metadata and the ability to filter by test run status. (127015832)&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Marvin Lin</name></author><category term="swift" /><category term="Xcode" /><category term="Swift" /><summary type="html">Here are the New Features from the Xcode 16 release notes:</summary></entry><entry xml:lang="en"><title type="html">Cocoapods Enters Maintain Mode</title><link href="http://localhost:4000/en/swift/cocoapods-enter-maintain-mode/" rel="alternate" type="text/html" title="Cocoapods Enters Maintain Mode" /><published>2024-08-15T23:33:00+08:00</published><updated>2024-08-15T23:33:00+08:00</updated><id>http://localhost:4000/en/swift/cocoapods-enter-maintain-mode</id><content type="html" xml:base="http://localhost:4000/en/swift/cocoapods-enter-maintain-mode/">&lt;h2 id=&quot;cocoapods-enters-maintain-mode-but-will-still-release-more-than-twice-a-year-to-keep-up-with-xcode-updates&quot;&gt;Cocoapods Enters Maintain Mode, But Will Still Release More Than Twice a Year to Keep Up with Xcode Updates&lt;/h2&gt;

&lt;p&gt;One evening, while scrolling through x (formerly Twitter), I stumbled upon a post retweeted by &lt;a href=&quot;https://blog.cocoapods.org/CocoaPods-Support-Plans/&quot;&gt;Orta Therox&lt;/a&gt; announcing that Cocoapods, after 13 years, has entered maintain mode.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/swift/cocoapods-enter-maintain-mode/pods_enter_maintain_mode.png&quot; alt=&quot;cocoapods announcement: enter maintain mode&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;key-points&quot;&gt;Key Points&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Ensure security issues in the mainline are addressed.&lt;/li&gt;
  &lt;li&gt;Release at least twice a year to keep up with Xcode updates.&lt;/li&gt;
  &lt;li&gt;Review support requests every six months.&lt;/li&gt;
  &lt;li&gt;Maintain website infrastructure operations.&lt;/li&gt;
  &lt;li&gt;Support limitations: Will not actively follow up on GitHub issues as a support channel, nor commit to handling PRs for new features or application layer errors.&lt;/li&gt;
  &lt;li&gt;Consider turning the Specs repository to read-only to simplify security management and maintain existing builds in the long run.&lt;/li&gt;
  &lt;li&gt;For projects like React Native, which primarily acquire libraries via npm and not Trunk, such changes may be sufficient.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reasoning&quot;&gt;Reasoning&lt;/h2&gt;
&lt;p&gt;Since Apple introduced the Swift Package Manager (SPM), Cocoapods has faced significant competitive pressure, impacting its development momentum. With SPM being officially supported by Apple and integrated directly into its development environment, competing with Apple in the core area of package management tools is disadvantageous. Apple’s widespread influence and deep integration with its products have made developers lean towards choosing SPM as their dependency management tool, directly affecting Cocoapods’ market share and related development investments. Therefore, facing competition from Apple, Cocoapods needs to adjust its strategy to adapt to the evolving development ecosystem.&lt;/p&gt;

&lt;h2 id=&quot;impact-on-pods&quot;&gt;Impact on Pods&lt;/h2&gt;
&lt;p&gt;Since I have several older iOS projects underway and numerous interdependent modules using pods for management at work, it’s inevitable to start supporting SPM. Considering the upcoming changes:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Xcode 16 is expected to release in September 2024.&lt;/li&gt;
  &lt;li&gt;iOS 18 is likely to release in September 2024.&lt;/li&gt;
  &lt;li&gt;Swift 6, although optional, will appear with Xcode 16, with Swift 5.10 being the last of the version 5 series.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I anticipate that the development community will adapt to these changes by around early 2025. Therefore, I plan to initiate support for SPM starting in 2025.&lt;/p&gt;

&lt;h2 id=&quot;orta-theroxs-article-on-cocoapods-entering-maintain-mode&quot;&gt;&lt;a href=&quot;https://blog.cocoapods.org/CocoaPods-Support-Plans/&quot;&gt;Orta Therox’s Article on Cocoapods Entering Maintain Mode&lt;/a&gt;&lt;/h2&gt;</content><author><name>Marvin Lin</name></author><category term="swift" /><category term="Swift" /><category term="Cocoapods" /><category term="Xcode" /><summary type="html">Cocoapods Enters Maintain Mode, But Will Still Release More Than Twice a Year to Keep Up with Xcode Updates</summary></entry><entry xml:lang="zh"><title type="html">Cocoapods 進入 maintain mode</title><link href="http://localhost:4000/zh/swift/cocoapods-enter-maintain-mode/" rel="alternate" type="text/html" title="Cocoapods 進入 maintain mode" /><published>2024-08-15T22:10:00+08:00</published><updated>2024-08-15T22:10:00+08:00</updated><id>http://localhost:4000/zh/swift/cocoapods-enter-maintain-mode</id><content type="html" xml:base="http://localhost:4000/zh/swift/cocoapods-enter-maintain-mode/">&lt;h2 id=&quot;cocoapods-進入-maintain-mode但一年還會發佈兩次以上讓-pod-可以跟上-xcode-的更新&quot;&gt;Cocoapods 進入 maintain mode，但一年還會發佈兩次以上，讓 pod 可以跟上 Xcode 的更新&lt;/h2&gt;

&lt;p&gt;有一天晚上，我滑了 x (前身為推特)，突然滑到了，有人轉推了 &lt;a href=&quot;https://blog.cocoapods.org/CocoaPods-Support-Plans/&quot;&gt;Orta Therox&lt;/a&gt; 的文章，有 13 年歷史的 Cocoapods 開始進入 maintain mode 了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/swift/cocoapods-enter-maintain-mode/pods_enter_maintain_mode.png&quot; alt=&quot;cocoapods announcement: enter maintain mode&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;重點整理&quot;&gt;重點整理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;確保處理幹線的系統安全問題。&lt;/li&gt;
  &lt;li&gt;每年至少發布兩次版本以跟上 Xcode 更新。&lt;/li&gt;
  &lt;li&gt;每六個月檢查一次支持請求。&lt;/li&gt;
  &lt;li&gt;保持網站基礎設施運行。&lt;/li&gt;
  &lt;li&gt;支持限制: 不會積極跟進 GitHub 問題作為支持渠道，也不會承諾處理新增功能的 PR 或應用層錯誤。&lt;/li&gt;
  &lt;li&gt;考慮將 Specs 倉庫轉為只讀，以簡化安全管理，長遠保持現有構建運行。&lt;/li&gt;
  &lt;li&gt;對於如 React Native 等項目，這樣的變動可能足夠，因為它們的庫主要通過 npm 獲得而不是通過 Trunk。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;原因&quot;&gt;原因&lt;/h2&gt;
&lt;p&gt;自從 Apple 推出了 Swift Package Manager (SPM) 以後，CocoaPods 面臨了顯著的競爭壓力，這對其發展動力造成了影響。由於 SPM 是由 Apple 官方支持，直接整合在其開發環境中，這使得與 Apple 在包管理工具這一核心領域內進行競爭變得不太有利。Apple 的廣泛影響力和對其產品的深度整合，使得開發者傾向於選擇 SPM 作為依賴管理工具，這直接影響了 CocoaPods 的市場份額與相關的開發投入。因此，面對來自 Apple 的競爭，CocoaPods 在策略上需要做出調整，以適應不斷變化的開發生態。&lt;/p&gt;

&lt;h2 id=&quot;針對-pods-的這項變化&quot;&gt;針對 pods 的這項變化&lt;/h2&gt;
&lt;p&gt;因為我手上還有很早就啟動的 iOS 專案，工作上也有一堆互相依賴的模組在使用 pod 來管理，這個狀況必然要開始進行支援 SPM 的動作。考量到接下來會有這些動作&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Xcode 16 應該會在 2024 9 月 release&lt;/li&gt;
  &lt;li&gt;iOS 18 應該會在 2024 9 月 release&lt;/li&gt;
  &lt;li&gt;Swift 6 雖然可選，但會在 Xcode 16 時一起出現，Swift 5.10 會是最後的版 5 開頭版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;預估開發社群對於環境的變化，應該會在 2025 年新年前後吧。所以我心中啟動 SPM 的支援，應該會在 2025 開始進行。&lt;/p&gt;

&lt;h2 id=&quot;orta-therox-聲明-cocoapods-進入-maintain-mode-的文章&quot;&gt;&lt;a href=&quot;https://blog.cocoapods.org/CocoaPods-Support-Plans/&quot;&gt;Orta Therox 聲明 Cocoapods 進入 maintain mode 的文章&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;以下是機翻&quot;&gt;以下是機翻&lt;/h2&gt;

&lt;p&gt;TLDR: 我們依然在維護 CocoaPods，但我們會更明確地表達現在 CocoaPods 已進入維護模式。&lt;/p&gt;

&lt;p&gt;CocoaPods 已有約 13 年的歷史，這段時間內 iOS 開發的格局發生了巨大變化。我還記得那些小型共享庫的碎片化島嶼（例如：ASIHTTPRequest、Three20、SBJson、SSToolkit、iCarousel），它們升級說明複雜且構建設置困難。CocoaPods 簡化了這一過程，讓它成為 iOS 和 Mac 社區分享代碼的事實標準方法。&lt;/p&gt;

&lt;p&gt;2015 年，蘋果宣布 CocoaPods 項目已被 Sherlock，因為他們將創建自己的包管理器：Swift Package Manager。這一舉措有效地使 CocoaPods 失去了前進的動力，因為在自己的領域與蘋果競爭很少是值得志願者花時間的戰鬥。&lt;/p&gt;

&lt;p&gt;自從 9 年前 Swift Package Manager 宣布以來，核心團隊的成員各自有持續維護的原因：一種責任感、被雇佣來維護使用 CocoaPods 的庫或應用、在大型項目的構建基礎設施工作中 CocoaPods 是關鍵部分，或只是對社區的熱愛。&lt;/p&gt;

&lt;p&gt;然而，隨著時間的推移 - 這些聯繫也變得越來越脆弱，工作變動，人們轉移到新的生態系統，我們慢慢地將 CocoaPods 轉移到一個只有在外部因素促使時才會進行工作的地方。這可能是我在博客上過去幾年報告的安全問題，或者 Xcode 的重大更改，這需要我們調整一些設置並創建一個新版本。&lt;/p&gt;

&lt;p&gt;如果 CocoaPods 的唯一受眾是原生 Cocoa 開發者，CocoaPods 的使用應該在下降，然而，情況並非如此。React Native 和 Flutter 的流行確保了大多數使用量/流量指標隨著時間穩步上升。&lt;/p&gt;

&lt;p&gt;這使 CocoaPods 身處一個奇怪的位置，許多維護者不使用它，蘋果已經維護了一個替代品 9 年，而項目的新用戶幾乎不知道 CocoaPods 存在或它的作用。&lt;/p&gt;

&lt;p&gt;所以，我們得出結論，我們需要弄清楚項目的狀況以及過去幾年我們作為維護者如何對待它。&lt;/p&gt;

&lt;h3 id=&quot;cocoapods-是如何維護的&quot;&gt;CocoaPods 是如何維護的&lt;/h3&gt;
&lt;p&gt;嚴格來說，我們不打算改變我們維護 CocoaPods 的方式。我們只是要開始清楚地表明 CocoaPods 是如何被維護的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;我們將確保處理幹線的系統安全問題&lt;/li&gt;
  &lt;li&gt;我們將目標是每年至少發布 2 次版本以跟上 Xcode 更新&lt;/li&gt;
  &lt;li&gt;我們將目標是每 6 個月查看一次幹線的支持請求&lt;/li&gt;
  &lt;li&gt;我們將保持網站基礎設施不完全崩潰&lt;/li&gt;
  &lt;li&gt;我們對讓 CocoaPods 更加未來友好的 PR 持開放態度&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;我們不會做的事&quot;&gt;我們不會做的事：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;我們不會積極跟蹤 GitHub 問題作為個人支持渠道&lt;/li&gt;
  &lt;li&gt;我們不打算在新功能方面進行積極的 CocoaPods 開發&lt;/li&gt;
  &lt;li&gt;我們不會保證處理添加新功能的人的 PR 或應用層面的錯誤&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;長期計劃&quot;&gt;長期計劃&lt;/h3&gt;
&lt;h4 id=&quot;只讀規格&quot;&gt;只讀規格&lt;/h4&gt;
&lt;p&gt;我們正在討論在非常長的、多年的基礎上，我們可以通過將 Specs 倉庫轉換為只讀來大幅簡化 CocoaPods 幹線的安全性。像 Specs 倉庫和 CDN 這樣的基礎設施仍將運行，只要 GitHub 和 jsDelivr 繼續存在，這很可能是很長一段時間。這將保持所有現有構建的運行。&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="swift" /><category term="Swift" /><category term="Cocoapods" /><category term="Xcode" /><summary type="html">Cocoapods 進入 maintain mode，但一年還會發佈兩次以上，讓 pod 可以跟上 Xcode 的更新</summary></entry><entry xml:lang="en"><title type="html">For projects using Xcode 15.3 or higher, please upgrade Firebase to version 10.22.0 or higher, otherwise, the application may crash upon release</title><link href="http://localhost:4000/en/swift/xcode15-4-need-using-firebase-new-version/" rel="alternate" type="text/html" title="For projects using Xcode 15.3 or higher, please upgrade Firebase to version 10.22.0 or higher, otherwise, the application may crash upon release" /><published>2024-07-27T11:32:00+08:00</published><updated>2024-07-27T11:32:00+08:00</updated><id>http://localhost:4000/en/swift/xcode15-4-need-using-firebase-new-version</id><content type="html" xml:base="http://localhost:4000/en/swift/xcode15-4-need-using-firebase-new-version/">&lt;p&gt;If you are using Xcode version 15.3 or higher and your project utilizes Firebase, please ensure to upgrade Firebase to version 10.22.0 or higher; otherwise, your application may crash upon release.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/swift/crash-on-firebase10-10-0/crashlytics.png&quot; alt=&quot;Crashlytics report on xcode15.4 vs. firebase 10.10.0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In early July, our team agreed to upgrade to Xcode 15.4. While other pods were kept stable, we noticed an increase in crash rates post-launch, as depicted in the image above.&lt;/p&gt;

&lt;p&gt;Crashlytics analysis revealed that the crashes originated from the AppDelegate and were associated with compiler-generated code.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/swift/crash-on-firebase10-10-0/crash_on_AppDelegate.png&quot; alt=&quot;Crash starts from AppDelegate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Further insights were gained from a Stack Overflow post, which recommended upgrading to Firebase version 10.22.0 or higher.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/78122992/3764854&quot;&gt;Stack Overflow discussion on potential crash issues and the recommendation to upgrade Firebase to 10.22.0 or higher&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/firebase/firebase-ios-sdk/issues/11403&quot;&gt;Firebase GitHub issues - 11403 discusses a series of related problems&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The reasons are similar to those in my project, relating to nanopb.&lt;/p&gt;

&lt;h2 id=&quot;if-upgrading-to-xcode-153-or-higher&quot;&gt;If Upgrading to Xcode 15.3 or Higher&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Make sure that the Firebase version is at least 10.22.0&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;crash-log&quot;&gt;Crash log&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Crashed: com.apple.main-thread
EXC_BAD_ACCESS KERN_INVALID_ADDRESS 0x000000017338126c
0
nanopb
encode_field + 100
24
UIKitCore
keypath_get_selector_hoverStyle + 11024
25
&amp;lt;compiler-generated&amp;gt; - Line 4337149088
static AppDelegate.$main() + 4337149088
26
&amp;lt;compiler-generated&amp;gt; - Line 4337152352
type metadata accessor for AppDelegate + 4337152352
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Marvin</name></author><category term="swift" /><category term="swift" /><category term="firebase" /><category term="xcode" /><summary type="html">If you are using Xcode version 15.3 or higher and your project utilizes Firebase, please ensure to upgrade Firebase to version 10.22.0 or higher; otherwise, your application may crash upon release.</summary></entry><entry xml:lang="zh"><title type="html">要升級 Xcode 15.3 以上的專案，請將 Firebase 升到 10.22.0 以上，否則發佈後會閃退</title><link href="http://localhost:4000/zh/swift/xcode15-4-need-using-firebase-new-version/" rel="alternate" type="text/html" title="要升級 Xcode 15.3 以上的專案，請將 Firebase 升到 10.22.0 以上，否則發佈後會閃退" /><published>2024-07-27T11:32:00+08:00</published><updated>2024-07-27T11:32:00+08:00</updated><id>http://localhost:4000/zh/swift/xcode15-4-need-using-firebase-new-version</id><content type="html" xml:base="http://localhost:4000/zh/swift/xcode15-4-need-using-firebase-new-version/">&lt;p&gt;如果你使用了 Xcode 15.3 以上的版本，並且專案中使用了 Firebase，請注意 Firebase 版本要升到 10.22.0 以上，否則發佈後會閃退。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/swift/crash-on-firebase10-10-0/crashlytics.png&quot; alt=&quot;Crashlytics report on xcode15.4 vs. firebase 10.10.0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;7月初，團隊講好一起把 Xcode 升到 15.4 以上，其他的 pods 都是固定的，然後一線，閃退率就起來了，上面的圖就是上線後的結果。&lt;/p&gt;

&lt;p&gt;看了 Crashlytics，發生閃退的地方是 AppDelegate 而且是 Compiler generated code。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/swift/crash-on-firebase10-10-0/crash_on_AppDelegate.png&quot; alt=&quot;Crash starts from AppDelegate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看了一下 stack overflow 的資訊，有提到的是這篇。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/a/78122992/3764854&quot;&gt;Stack overflow 查到可能閃退的點，並且建議升級到 Firebase 10.22.0 以上&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/firebase/firebase-ios-sdk/issues/11403&quot;&gt;Firebase github issues - 11403 有提到一系列原因&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;原因和我專案上的類似，和 nanopb 有關。&lt;/p&gt;

&lt;h2 id=&quot;如果升到-xcode-153-以上的版本&quot;&gt;如果升到 Xcode 15.3 以上的版本&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;請一定要檢查 Firebase 的版本是不是在 10.22.0 以上&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;crash-log&quot;&gt;Crash log&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Crashed: com.apple.main-thread
EXC_BAD_ACCESS KERN_INVALID_ADDRESS 0x000000017338126c
0
nanopb
encode_field + 100
24
UIKitCore
keypath_get_selector_hoverStyle + 11024
25
&amp;lt;compiler-generated&amp;gt; - Line 4337149088
static AppDelegate.$main() + 4337149088
26
&amp;lt;compiler-generated&amp;gt; - Line 4337152352
type metadata accessor for AppDelegate + 4337152352
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Marvin</name></author><category term="swift" /><category term="swift" /><category term="firebase" /><category term="xcode" /><summary type="html">如果你使用了 Xcode 15.3 以上的版本，並且專案中使用了 Firebase，請注意 Firebase 版本要升到 10.22.0 以上，否則發佈後會閃退。</summary></entry><entry xml:lang="en"><title type="html">Designing Data-Intensive Applications - Chapter 6 Notes</title><link href="http://localhost:4000/en/programming/data-intensive-applications.md/" rel="alternate" type="text/html" title="Designing Data-Intensive Applications - Chapter 6 Notes" /><published>2024-07-17T13:50:00+08:00</published><updated>2024-07-17T13:50:00+08:00</updated><id>http://localhost:4000/en/programming/data-intensive-applications.md</id><content type="html" xml:base="http://localhost:4000/en/programming/data-intensive-applications.md/">&lt;p&gt;There is no silver bullet: https://g.co/kgs/G7QbDr&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;designing-data-intensive-applications---chapter-6-notes&quot;&gt;Designing Data-Intensive Applications - Chapter 6 Notes&lt;/h3&gt;

&lt;p&gt;There is no silver bullet &lt;a href=&quot;https://g.co/kgs/G7QbDr&quot;&gt;https://g.co/kgs/G7QbDr&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*ifN_ysbEQV3aPal21VYuXQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;why-do-we-need-partitioning&quot;&gt;Why do we need partitioning?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Increased scalability
    &lt;ul&gt;
      &lt;li&gt;As business volume increases, a single server will eventually hit its limit. Choosing an appropriate partitioning strategy can greatly benefit future business needs.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Improved efficiency
    &lt;ul&gt;
      &lt;li&gt;A well-designed partitioning strategy can enhance lookup efficiency.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Enhanced security
    &lt;ul&gt;
      &lt;li&gt;In certain situations, data can be divided into sensitive and non-sensitive categories and stored separately with security controls in place.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Greater operational flexibility
    &lt;ul&gt;
      &lt;li&gt;Multiple storage locations allow for more optimization methods, such as management, monitoring, backup, and restore.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data type-specific storage
    &lt;ul&gt;
      &lt;li&gt;Partitioning can be based on data type. For large binary data, storing in an optimized blob storage area is better than in a document database.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Increased reliability
    &lt;ul&gt;
      &lt;li&gt;Partitioning can prevent single points of failure.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;partitioning-strategies&quot;&gt;Partitioning Strategies&lt;/h3&gt;

&lt;h3 id=&quot;horizontal-partitioning&quot;&gt;Horizontal Partitioning&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*aLGFA24i3vdS5Fioh3SCKg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Each partition contains a portion of the data. A good strategy ensures each partition equally shares the system load. Each partition has the same schema and is also known as a shard.&lt;/p&gt;

&lt;p&gt;An example of horizontal partitioning is arranging partitions by alphabetical order of keys. The most crucial aspect is deciding the range of the sharding key, as once the strategy is implemented and online, it is difficult to adjust.&lt;/p&gt;

&lt;p&gt;This doesn’t mean that each partition should contain the same “amount” of data. For instance, if using an encyclopedia example, a publisher might design the books so that each volume has a similar thickness, arranging by alphabetical order to achieve balanced partitioning.&lt;/p&gt;

&lt;p&gt;In database contexts, design might reflect real-world scenarios. Some shards might hold large amounts of data with low read/write frequency, while others hold smaller data with high read/write frequency.&lt;/p&gt;

&lt;p&gt;Considerations:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Ensure each shard does not exceed physical machine limits.&lt;/li&gt;
  &lt;li&gt;Avoid creating “hotspots” that affect performance or reliability. For example, using customers’ first letters for key classification can cause uneven distribution due to linguistic habits. An alternative is hashing keys before distributing them into partitions.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;vertical-partitioning&quot;&gt;Vertical Partitioning&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*XXjsPN9UtOCuhKUV9Bj7HA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Each partition holds a subset of the original data. For example, split fields into frequently used and less frequently used parts, storing each in different partitions.&lt;/p&gt;

&lt;p&gt;Vertical partitioning is commonly used to reduce I/O and lower the cost of frequently fetching data.&lt;/p&gt;

&lt;p&gt;As illustrated in Fig2, one partition stores frequently accessed data like product names, descriptions, and prices. Another partition stores inventory and last order dates. This system frequently queries product-related data for app display, while inventory and order data are often shown together.&lt;/p&gt;

&lt;p&gt;Additional benefits:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Separating frequently changing items from infrequently changing ones. For example, product names, descriptions, and prices rarely change, whereas inventory counts and last purchase dates do. The less frequently changing data can be cached more easily.&lt;/li&gt;
  &lt;li&gt;Sensitive data can be partitioned and protected with additional security controls.&lt;/li&gt;
  &lt;li&gt;Vertical partitioning reduces the need for concurrent access. For instance, during an order, inventory and last purchase date change without locking the entire row. This strategy allows more rows per page in MSSQL compared to horizontal partitioning.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;functional-partitioning-microsoft-article&quot;&gt;Functional Partitioning (Microsoft Article)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*MUsz-zJi4R9v_hZRYzaacw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Functional partitioning divides data by usage. For example, in an e-commerce system, product inventory data might be in one partition, while invoices/receipts are in another.&lt;/p&gt;

&lt;p&gt;If business logic boundaries are clear, functional partitioning can improve efficiency. A common scenario is separating read-write data from read-only data. In Fig3, inventory data and customer data are in different partitions.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;key-or-hashed-based-sharding&quot;&gt;Key or Hashed-based Sharding&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*Fac4H-wdk02et48Lm9thiw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Assume you have four database servers, each request with an application id. Using hash and mod, you can distribute data across the four machines.&lt;/p&gt;

&lt;p&gt;The main disadvantage of this method is that elastic load balancing (dynamically adding/removing database servers) becomes challenging and costly.&lt;/p&gt;

&lt;p&gt;If you want to add six more machines, you must remap and migrate data, and adjust your hash function from mod 4 to mod 10.&lt;/p&gt;

&lt;p&gt;There are ways to achieve seamless transitions, such as Consistent Hashing. Refer to the following resource:
&lt;a href=&quot;https://www.acodersjourney.com/system-design-interview-consistent-hashing/&quot;&gt;https://www.acodersjourney.com/system-design-interview-consistent-hashing/&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;directory-based-sharding&quot;&gt;Directory-based Sharding&lt;/h3&gt;

&lt;p&gt;Directory-based shard partitioning involves adding a lookup service in front of the partitions. The lookup service knows the current partition scheme and maintains a map record within the system.&lt;/p&gt;

&lt;p&gt;Clients first query the lookup service to find out which shard contains the entity before performing the lookup.&lt;/p&gt;

&lt;p&gt;Advantages:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Solves elastic scaling issues without using consistent hashing. Assume the previous expansion scenario with four database servers and hashed-based partitioning. Now, add six more database servers without downtime.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Steps:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The lookup service still uses mod 4 hash function.&lt;/li&gt;
  &lt;li&gt;Determine how data should be divided under mod 10 conditions.&lt;/li&gt;
  &lt;li&gt;Write a script to copy all data to the new six shards, without deleting data from the original four.&lt;/li&gt;
  &lt;li&gt;Once copying is complete, change the hash function in the lookup service from mod 4 to mod 10.&lt;/li&gt;
  &lt;li&gt;Purge or clean up data from the old four shards.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Considerations:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;During migration, users might still update data. Possible solutions include switching the system to read-only mode or temporarily storing data in another service, then moving it back after migration.&lt;/li&gt;
  &lt;li&gt;Copying and cleaning up significantly impacts performance. Possible solutions are cloning and elastic load balancing, though both are costly.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;reference-articles&quot;&gt;Reference Articles&lt;/h3&gt;

&lt;p&gt;Partitioning Articles:
&lt;a href=&quot;https://www.acodersjourney.com/database-sharding/&quot;&gt;https://www.acodersjourney.com/database-sharding/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Consistent Hashing:
&lt;a href=&quot;https://www.acodersjourney.com/system-design-interview-consistent-hashing/&quot;&gt;https://www.acodersjourney.com/system-design-interview-consistent-hashing/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Microsoft on Workload and Hotspot Mitigation:
&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/best-practices/data-partitioning&quot;&gt;https://docs.microsoft.com/en-us/azure/architecture/best-practices/data-partitioning&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By &lt;a href=&quot;https://medium.com/@atimis19&quot;&gt;Marvin Lin&lt;/a&gt; on &lt;a href=&quot;https://medium.com/p/c8b1ddc94554&quot;&gt;November 2, 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/designing-data-intensive-applications-notes-c8b1ddc94554&quot;&gt;Canonical link&lt;/a&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="programming" /><category term="system design" /><category term="programming" /><summary type="html">There is no silver bullet: https://g.co/kgs/G7QbDr</summary></entry><entry xml:lang="en"><title type="html">Flyweight Pattern - Lightweight Mode (Flyweight Pattern)</title><link href="http://localhost:4000/en/swift/flyweight-pattern/" rel="alternate" type="text/html" title="Flyweight Pattern - Lightweight Mode (Flyweight Pattern)" /><published>2024-07-17T13:35:00+08:00</published><updated>2024-07-17T13:35:00+08:00</updated><id>http://localhost:4000/en/swift/flyweight-pattern</id><content type="html" xml:base="http://localhost:4000/en/swift/flyweight-pattern/">&lt;h3 id=&quot;flyweight-pattern---lightweight-mode-flyweight-pattern&quot;&gt;Flyweight Pattern - Lightweight Mode (Flyweight Pattern)&lt;/h3&gt;

&lt;p&gt;This article introduces the Flyweight Pattern using examples and scenarios from &lt;a href=&quot;https://refactoring.guru/design-patterns/flyweight&quot;&gt;refactoring.guru&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Source: &lt;a href=&quot;https://refactoring.guru/design-patterns/flyweight&quot;&gt;https://refactoring.guru/design-patterns/flyweight&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;scenario&quot;&gt;Scenario:&lt;/h4&gt;

&lt;p&gt;You’ve developed an FPS game featuring missiles, bullets, and various cool effects, which you and your friends have started to play.&lt;/p&gt;

&lt;h3 id=&quot;but-however-it-works-on-your-machine&quot;&gt;But, However, “It works on your machine”&lt;/h3&gt;

&lt;p&gt;On your friend’s computer, the game crashes after a few minutes! The gaming experience on your friend’s system is terrible. After debugging for several hours and sifting through the logs, you pinpoint the issue to RAM insufficiency. Your computer has superior specs, but your friend’s doesn’t, leading to RAM depletion.&lt;/p&gt;

&lt;p&gt;The RAM consumption issues stem from the particle system you developed. Each particle, like bullets or missiles, spawns a particle object whenever it appears on the screen, eventually crashing the system due to RAM overload.&lt;/p&gt;

&lt;p&gt;As shown in the image below, each particle takes up 21 KB. With 1,000,000 particles, that would require 21 GB of RAM.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*G4GebBvS7ZChon7wEhSvZg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;from refactoring.guru&lt;/p&gt;

&lt;p&gt;Here’s a scene from Overwatch.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*bZSGkmXGYofMadtii2wyGQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*UzKC0uTVHQXLaqTyZhmNNA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How can the Flyweight pattern improve your game’s performance?&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;how-flyweight-reduces-system-load&quot;&gt;How Flyweight Reduces System Load&lt;/h3&gt;

&lt;p&gt;Revisiting the “Particle” class, consider the following:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*4dPir95Ideb9wzMRjK9hbg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You’ll notice two properties that can be made immutable (internal data):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;color&lt;/li&gt;
  &lt;li&gt;sprite&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Other attributes that vary (external data) include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;particle&lt;/li&gt;
  &lt;li&gt;coordinates&lt;/li&gt;
  &lt;li&gt;vector&lt;/li&gt;
  &lt;li&gt;speed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*5r80IzFWvGH9MCL0Kgm8nA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Looking back at the system:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*5yXJEnkUFcrlOgFIqbz86g.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The most resource-intensive element remains the sprite. With the same number of particles and without initializing new internal data, the requirement is 32MB of RAM. In contrast to the non-design pattern scenario requiring 21 GB, this design allows the game to run smoothly even on your friend’s computer.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Is it over? Have we fully utilized the design pattern?&lt;/p&gt;

&lt;h3 id=&quot;design-patterns-can-be-layered&quot;&gt;&lt;strong&gt;Design patterns can be layered!&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;adding-an-external-object-pool-for-further-optimization&quot;&gt;Adding an External Object Pool for Further Optimization&lt;/h3&gt;

&lt;p&gt;In practice, an “object pool” is often added to store the “internal information.”&lt;/p&gt;

&lt;p&gt;In this case, since there is a main class, Game, that stores Particles, the system first checks the pool for unused particles to reuse them by injecting “external information” (vector, speed, coordinates). If no suitable particles are in the pool, a new one is initialized.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*9oTHsQUlMpuXtZcj47OviA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once a particle is no longer needed, it is returned to the pool for future use.&lt;/p&gt;

&lt;p&gt;This can be seen as a combination of the Object Pool and Flyweight patterns. In UIKit, an essential component uses this hybrid approach.&lt;/p&gt;

&lt;p&gt;Further optimizations are made even to the external information using another layer of the Flyweight pattern.&lt;/p&gt;

&lt;p&gt;Flyweight of a Flyweight. There’s always room for finer detail.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Further into your career, you might not start in a “real” game company in Taiwan; you could be an iOS frontend developer. No matter your field, everyone starts with frameworks in 2022. If you are an iOS frontend developer, consider which system components in iOS might be applying the “Flyweight Pattern (Flyweight Pattern).”&lt;/p&gt;

&lt;p&gt;By &lt;a href=&quot;https://medium.com/@atimis19&quot;&gt;Marvin Lin&lt;/a&gt; on &lt;a href=&quot;https://medium.com/p/a5ab3b6054f&quot;&gt;August 10, 2022&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/flyweight-pattern-%E8%A0%85%E9%87%8F%E7%B4%9A%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-a5ab3b6054f&quot;&gt;Canonical link&lt;/a&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="swift" /><category term="Swift" /><category term="Design Pattern" /><category term="Flyweight Pattern" /><summary type="html">Flyweight Pattern - Lightweight Mode (Flyweight Pattern)</summary></entry></feed>