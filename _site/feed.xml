<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-14T21:10:06+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Marvin Lin’s Blogger</title><subtitle>這個 blog 是包含了的軟體開發、投資、經驗和生活故事。透過這個 blog，我希望分享自己的生活和見聞，同時也透過這個平台與讀者交流互動，建立起彼此的社群。</subtitle><entry><title type="html"></title><link href="http://localhost:4000/2023/03/14/2018-06-09-Prototype-pattern-in-swift.html" rel="alternate" type="text/html" title="" /><published>2023-03-14T21:10:06+08:00</published><updated>2023-03-14T21:10:06+08:00</updated><id>http://localhost:4000/2023/03/14/2018-06-09-Prototype-pattern-in-swift</id><content type="html" xml:base="http://localhost:4000/2023/03/14/2018-06-09-Prototype-pattern-in-swift.html">&lt;h1 id=&quot;prototype-pattern-原型模式-in-swift-reference-type-vs-value-type-的不同&quot;&gt;Prototype Pattern (原型模式) in Swift (Reference type vs. Value type) 的不同&lt;/h1&gt;

&lt;p&gt;這一篇文章是看了 “Pro Design Patterns in Swift “ 後的心得，把原型模式整理後寫成中文的記錄。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;prototype-pattern-原型模式-in-swift-reference-type-vs-value-type的不同&quot;&gt;Prototype Pattern (原型模式) in Swift (Reference type vs. Value type) 的不同&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*oSH09tpBPZt9tTyivxUxhg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這一篇文章是看了 “Pro Design Patterns in Swift “ 後的心得，把原型模式整理後寫成中文的記錄。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;情境:忍者頭目&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*yGesVxbCpDZbw7gmPCClBQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;先假設你要寫一個遊戲，某一關的頭目是忍者。 這一關裡，Boss 有各種 nerf 狀態，像是中毒、減傷、破甲、緩速、拌筋，等共30種 nerf 狀態，而 buff 有另外 10 種狀態。&lt;/p&gt;

&lt;p&gt;打到 1/2 血的時候， boss 會使用絕招 -「影分身」。&lt;/p&gt;

&lt;p&gt;影分身會複製出 4 個和 boss 狀態一模一樣的分身，血量和各種 buff, nerf 狀態會同時複製。&lt;/p&gt;

&lt;p&gt;影分身受傷的時候，本體不會有影響，但本體 hp 歸 0 的時候，才進行寶物結算。&lt;/p&gt;

&lt;p&gt;如果這樣類型的場合，用 Prototype 就是一個不錯的選擇，但請記得還有一句話，「這世上沒有銀色子彈」，在使用前，請依照場景及條件，去選擇一個最適合當下情況的模式，而不是讓「非用 XX 模式才是正道」這種想法去寫 app。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;No Silver Bullet — Essence and Accidents of Software Engineering&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*VFfKvJ1VOTkkPaw2S3xGQw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Prototype pattern 的操作方式&lt;/p&gt;

&lt;p&gt;使用原型模式大概可以分成兩個步驟:&lt;/p&gt;

&lt;p&gt;Step 1: 先生出模板，最簡單的方式可以用 let aStruct = SomeStruct(propertyA:a, propertyB:b) 這樣的方式&lt;/p&gt;

&lt;p&gt;Step 2:把模板複製出一份，再開始修改裡面的 property，改成你要的物件。&lt;/p&gt;

&lt;p&gt;在書上有例舉出來使用原型模式的各個要點，我這邊整理在下面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*U_RaBhdDQuXps5sEfMS7fg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以這模式的好處來說，就是他使用的是 Copy ，雖然書上有寫說他可以避免 init 所花的成本，但 Swift 下的 Copy，其本上還是會跑一次 init()，所以我並無法理解他所提到的「成本」到底是指哪邊的成本，但還是照著書上所寫的列出來。&lt;/p&gt;

&lt;p&gt;我們先用聚會的提醒來做例子。&lt;/p&gt;

&lt;p&gt;如上所寫的，一個 Appointment 最重要的就是「和誰」、「什麼時間」、「哪個地點」。一開始的 beerMeeting 先設定為「和大學同學」在「星期五」的「酒吧」聚會，然後再複製出一份指定為 workMeeting，然後把設定調整成「和老闆」在「星期一」的「第二會議室」。這樣的模式就是「原型模式」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*XTf04r3akc_X4MaTafg7Cw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上的方法在 struct 等value type 物件是沒有問題的，但如果用在 class 等 reference type 的物件的時候，會因為指向同一個物件，而產生奇怪的結果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*dpVBVnLBol45bC0x6z-nXQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你可以發現，你在 21~ 23 的行為，雖然都是針對 workMeeting 的 property 做操作，但同時也影響了 beerMeeting 這個物件。因為他在 reference type 的創建中，你並沒有真正的「複製」，你只是讓 workMeeting 去指向 beerMeeting 同樣指向的地方。所以當你一更改，beerMeeting 的 property 也會變，用下面這張圖就可以清楚看到指向同樣的東西的示意圖。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*A1bDJrel1mkaseu_BtiXdw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我在 Giphy 上找到這個神燈精靈的圖，算是可以解釋這種現象。下面這張圖的神燈精靈都只是原來的那一隻的分身。雖然看起來有很多隻，但如果他遭到神燈封印，那所有的分身照故事邏輯來說，都會同時被封印。這就是對一個物件改變，但所有指向的東西也一起改變。&lt;/p&gt;

&lt;p&gt;看起來都是複製品，但其實都是那一個精靈&lt;/p&gt;

&lt;p&gt;如果要對 class 做複製的行為，那你就要讓物件 confirm NSCopying 的 protocol。以下是範例，但因為是範例，所以直接使用了 force unwrap，在寫專案的時候，&lt;strong&gt;記得用其他方法去避免 as! 的產生&lt;/strong&gt;，因為你每放了一個驚嘆號，就是放了一顆地雷，你只是不知道什麼時候會引爆。&lt;/p&gt;

&lt;p&gt;這邊在 confirm NSCopying 後，要實作 copy()，return 的值就是自已的類別，並把當下的值塞入進行 init()。這樣你就得到一個內部的值完全一樣的拷貝版。之後再對裡面的 property 做變更就行了。&lt;/p&gt;

&lt;p&gt;不過拷貝可以講的，到這邊還沒結束。這個 Appointment 類別裡面的三個值，都是 String。 String 是 value type 所以當你複製了一份 Appointment 時，這三個值毫無懸念的也以 value type 的型式 copy 了一份。所以後來複製出來的 workMeeting 裡面的值當然不會引響 beerMeeting。那如果裡面的值也是一個 reference type 的話，Appointment 的 NSCopying 會對那個 reference type 也會產生 copy 效果嗎?&lt;/p&gt;

&lt;p&gt;我們現在定義一個 Location 的類別並取代原來的 place: String 試試看。&lt;/p&gt;

&lt;p&gt;class Location {&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var name:String  
 var address:String

 init(name:String, address:String) {  
     self.name = name; self.address = address  
 }   }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;現在 beerMeeting 的 place 已經是一個 reference type，那在 copy 的時候， self.place 會不會也被 copy 一份呢?從下面這邊我們可以看到 place 的值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*fmMQLtti93RjksF1EdVHOQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;beerMeeting 的place 在更改workMeeting時一起被更改了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;這樣的 copy 行為，有一種稱呼，叫做 “ shallow copy” (淺拷貝)。這是指拷貝的時候只拷貝了參照的行為，並沒有把實體真的拷貝一份。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;相反的，在拷貝的時候，把實體再複製一遍的這個行為，叫做 “deep copy” (深拷貝)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*gzdxGTOSNFlkERalOdTxZQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;這張圖可以清楚的看到Location這個物件是怎麼被指向&lt;/p&gt;

&lt;p&gt;如果你要讓 Location 也能被 copy ，那 Location 也要 confirm NSCopying 的 protocol ，並且在 Appointment 進行複製的時候使用 copy()。&lt;/p&gt;

&lt;p&gt;下圖可以看到 clone 的 place 已經和 prototype 的 place 沒有關係了。這就是所謂的 “Deep copy” (深拷貝)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*2uWOyvT8x_VPu62t_U5cuQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;書中也提到，深拷貝與淺拷貝並沒有優劣之別，你應該就當下的情況來決定你的物件是要走深拷貝或是淺拷貝。考量的點依照重要性如下表列。&lt;/p&gt;

&lt;p&gt;1、該物件是怎麼被使用的?&lt;/p&gt;

&lt;p&gt;2、Copy 所需要的記憶體和成本&lt;/p&gt;

&lt;p&gt;3、寫 Copy 所需要的工&lt;/p&gt;

&lt;p&gt;我們從第一個要點來思考前一個 Appointment 的範例。如果這個 Appointment 只會給單一 user 使用，這樣的 Appointment 預設應該會是深拷貝比較好，因為 user 複製了一個長得差不多的行程，下一步一定是去修改他，這才是 user 複製的目的。&lt;/p&gt;

&lt;p&gt;但如果這個 Appointment 是集體的行事曆，那依照各種場合不同，也有可能是淺拷貝比較好。比如說遇到了會議室滿了、客戶臨時來訪等情況。當有權限的人更改了會議的地點或是時間，其他人參與者應該要知道一樣的情報。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以在選擇使用深拷貝或是淺拷貝的時候，最重要的就是使用情境。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;下一段，要說的是 prototype 模式中，可以讓某個物件在複製另一個物件的時候，不用知道對方的 init 條件，來降低耦合性。&lt;/p&gt;

&lt;p&gt;先來假設一個情境，你的客戶在需求中要求紀錄 Message 這個物件，而且在開案的時候和你說:「這個 Message 要求很簡單，因為發送方一定是持有手機的人，所以你只要包含傳送方和內容就好了。另外這些 message 要 cache 起來。」&lt;/p&gt;

&lt;p&gt;所以，依照需求，你的 Message 和 Message Logger 只要這樣就好了。&lt;/p&gt;

&lt;p&gt;然後在結案前二周，客戶突然跟你說，他要追加一個「簡單的」需求(客戶和工程師的日常)，就是某些 Message 會是另一個人發過來的，讓對話中的兩個人看到。同樣的，這個 Message 也要進同一份 Message Logger。&lt;/p&gt;

&lt;p&gt;如上所視，這個作法「暫時的」解決了問題。你只要在 logMessage 前先判斷他是哪一種 Message ，然後再用 init 的方式生出複製品然後加入 array 。&lt;/p&gt;

&lt;p&gt;而客戶的日常-「增加需求」會不時的發動，如果又過了一個禮拜(結案前一周)，客戶又加了一個「簡單的」需求，要求兩種新的 message 種類，你該用什麼心情面對? 這邊有一個圖可以表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*_bgv9PCoER5Z1iAtKRiSEg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假的~~~趕快把客戶的聯絡方式關起來 (誤)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;或者，你可以在一開始的 Message 就讓這個類別可以自己拷貝一份出來，因為 MessageLogger 在使用拷貝的時候並不知道 Message init 的條件，所以不論你後面增加了幾十種 Message 的 sub class，Message Logger 這邊的程式碼都不需要改寫。&lt;/p&gt;

&lt;p&gt;↓使用 Prototype Pattern 的程式碼&lt;/p&gt;

&lt;p&gt;在看完這篇文章後，如果想測測看自己對 Deep copy, Shallow copy 的了解，你可以打開 Playground 寫段這樣的 code，然後先預測他的結果再按下執行。&lt;/p&gt;

&lt;p&gt;1、創一個空 array&lt;/p&gt;

&lt;p&gt;2、在這個 array 裡面塞一個 class，這個 class 要有可以變更的 store property，舉例 (忍者龜裡面的達文西)&lt;/p&gt;

&lt;p&gt;3、複製這個 array (使用 var b = a 這種方式)&lt;/p&gt;

&lt;p&gt;4、修改複製出來 array 裡面的class 裡面的 property ，舉例(修改成拉斐爾)&lt;/p&gt;

&lt;p&gt;5、問題來了，請問原來 array 裡面的 class，會不會被改變呢?&lt;/p&gt;

&lt;p&gt;這邊就不公佈答案了，你就自己試試看吧&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你己經理解了，那這邊公佈與否，結果都一樣。但如果你還沒理解，你可能只是把答案背起來而已，換個場合換個條件可能就爆炸了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;By &lt;a href=&quot;https://medium.com/@atimis19&quot;&gt;Marvin Lin&lt;/a&gt; on &lt;a href=&quot;https://medium.com/p/bb47c13baecb&quot;&gt;June 9, 2018&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/prototype-pattern-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-in-swift-bb47c13baecb&quot;&gt;Canonical link&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author></entry><entry><title type="html">GitHub Page 部落格弄好了，未來文章都會 po 在 GitHub Page 上了</title><link href="http://localhost:4000/life/2023/03/14/future-article-will-post-on-page.html" rel="alternate" type="text/html" title="GitHub Page 部落格弄好了，未來文章都會 po 在 GitHub Page 上了" /><published>2023-03-14T21:09:00+08:00</published><updated>2023-03-14T21:09:00+08:00</updated><id>http://localhost:4000/life/2023/03/14/future-article-will-post-on-page</id><content type="html" xml:base="http://localhost:4000/life/2023/03/14/future-article-will-post-on-page.html">&lt;h1 id=&quot;github-page-部落格弄好了未來文章都會-po-在-github-page-上了&quot;&gt;GitHub Page 部落格弄好了，未來文章都會 po 在 GitHub Page 上了&lt;/h1&gt;

&lt;p&gt;最近抽空花了點時間，使用了 ChatGPT 輔助，在 GitHub Page 上架了自己的部落格。使用的是 Ruby 的 Jekyll 框架，Jekyll 也是 GitHub Page 上直接推薦的框架。&lt;/p&gt;

&lt;p&gt;除了 Jekyll 以外，ChatGPT 還推薦了 Hugo、Hexo、Pelican、Gatsby。但我看了 GitHub 官網都推薦 Jekyll 後，就決定先試試 Jekyll 了。&lt;/p&gt;

&lt;p&gt;Github Page&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://moonandeye.github.io/&quot;&gt;https://moonandeye.github.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;現在已經搬移了部分文章，接下來都會繼續在 Page 上寫文章，短期還會在 medium 上貼相同文章，但再過一陣子，我就會停用 medium 了。&lt;/p&gt;

&lt;p&gt;畢竟，我還是想要有一個不是控在別人手上的 blog。&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="Life" /><category term="Life" /><category term="blog" /><summary type="html">GitHub Page 部落格弄好了，未來文章都會 po 在 GitHub Page 上了</summary></entry><entry><title type="html">最近用 ChatGPT 來做的事情</title><link href="http://localhost:4000/programming/2022/12/19/the-things-I-delegate-to-chatGPT.html" rel="alternate" type="text/html" title="最近用 ChatGPT 來做的事情" /><published>2022-12-19T15:25:00+08:00</published><updated>2022-12-19T15:25:00+08:00</updated><id>http://localhost:4000/programming/2022/12/19/the-things-I-delegate-to-chatGPT</id><content type="html" xml:base="http://localhost:4000/programming/2022/12/19/the-things-I-delegate-to-chatGPT.html">&lt;p&gt;最近有個 AI 對話機器人，在短期內爆紅，連結如下。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;最近用-chatgpt來做的事情&quot;&gt;最近用 ChatGPT 來做的事情&lt;/h3&gt;

&lt;p&gt;最近有個 AI 對話機器人，在短期內爆紅，連結如下。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://chat.openai.com/chat&quot;&gt;https://chat.openai.com/chat&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;很多人都會分享他做的事情，這邊我也貼一篇我讓他做的事情。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;寫詩&quot;&gt;寫詩&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*TwtFtA3WfnLVXbfKdEh9WQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;詩是寫出來了，但…沒有五言，也不是絕句。然後我就問 AI 懂不懂什麼叫五言絕句。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*9CsaTIzX767XTHDrQ7nYOQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;雖然知道五言絕句是什麼，但…寫不出正確的格式。&lt;/p&gt;

&lt;p&gt;所以，你也可以請他寫個程式開發的詩。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*rIPENTQoE7eQ1oOxXMMSXA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然後也試了 Android 的版本，看來是把詞抽換掉而已。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*9vmtLQ8BtpLwEws8QWUxIg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;寫文件企劃書得獎感言工作日誌&quot;&gt;寫文件，企劃書，得獎感言，工作日誌&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*6ieZPzpQDtRafQaLarnBnQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;嗯…這個 AI 活在朝九晚五的平行宇宙裡。&lt;/p&gt;

&lt;p&gt;接下來試試得獎感言&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*2F8NBB42s8soIUkDKxYo5A.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;還可以在得獎感言中加料&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*yemcnLV3Bvg4MTyHoBGSPg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;加料加到中樂透，也可以&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*fYKZapz3GtG2bxiY5eF88A.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;程式解題還可以選語言但這個很多人玩過了&quot;&gt;程式解題，還可以選語言(但這個很多人玩過了)&lt;/h3&gt;

&lt;p&gt;用 Go 寫一個數字是否質數&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*w29CcGSWeKIzGa6zO2ZCMA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用 perl 寫費布納西數列&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*x2tz0bUatid5h8u4FLR4zg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;寫一個登入網頁也能做到&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*ZUVOHz7Lio3DfQGSp6pUDg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;接下來這個世界，一定會因為這個產品，而開始不一樣的!&lt;/p&gt;

&lt;p&gt;By &lt;a href=&quot;https://medium.com/@atimis19&quot;&gt;Marvin Lin&lt;/a&gt; on &lt;a href=&quot;https://medium.com/p/d3f2a789ca53&quot;&gt;December 29, 2022&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/%E6%9C%80%E8%BF%91%E7%94%A8-chatgpt-%E4%BE%86%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85-d3f2a789ca53&quot;&gt;Canonical link&lt;/a&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="Programming" /><category term="ChatGPT" /><category term="AI" /><summary type="html">最近有個 AI 對話機器人，在短期內爆紅，連結如下。</summary></entry><entry><title type="html">WWDC22 Keynote, Platform State of the Union</title><link href="http://localhost:4000/swift/2022/06/10/WWDC22-keynote-platform-state-of-the-union.html" rel="alternate" type="text/html" title="WWDC22 Keynote, Platform State of the Union" /><published>2022-06-10T15:19:00+08:00</published><updated>2022-06-10T15:19:00+08:00</updated><id>http://localhost:4000/swift/2022/06/10/WWDC22-keynote-platform-state-of-the-union</id><content type="html" xml:base="http://localhost:4000/swift/2022/06/10/WWDC22-keynote-platform-state-of-the-union.html">&lt;p&gt;WWDC 22 開跑啦，這篇節錄 Keynote, Platform State of the union 中和 iOS 開發比較有關的點&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;wwdc22-keynote-platform-state-of-theunion&quot;&gt;WWDC22 Keynote, Platform State of the Union&lt;/h3&gt;

&lt;p&gt;WWDC 22 開跑啦，這篇節錄 Keynote, Platform State of the union 中和 iOS 開發比較有關的點&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*qM1SdBh8j6F8kAPt9lKH7g.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;WWDC22&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保留字更多了，除了 actor 還可以再加上 distributed actor&lt;/li&gt;
  &lt;li&gt;強化了正規表達，因為你玩 String.Index 會被玩到懷疑人生&lt;/li&gt;
  &lt;li&gt;NavigationView 已死，有事燒紙。現在有 NavigationStackView, NavigationSplitView&lt;/li&gt;
  &lt;li&gt;Swift Charts 出來了，2025 年後可以開始注意(iOS16 +)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*z0EBnr3tHCaVZErpC1FgoQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WidgetKit 再強化: Circular, Rectangular, Inline 三種，可以放在 lock screen&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*DFOuoajMMW3MDf9fMASkJg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*ePpGTEk6iJqm9Cdqsqf5sA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*xuYZHHa3nggMtDDcgu51bg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Live Activity 是新的 feature，可以在 lock screen 上看到即時訊息。在影片中，用 Uber 叫車不斷更新距離，還有籃球的比賽分數更新為案例。&lt;/li&gt;
  &lt;li&gt;沒看到 Lock screen 有沒有限制，但他用了叫車 widget 舉例，這應該是 socket 行為? (無法肯定)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*iccPyr1nNHeKvyRnwVto9g.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*-PMOQRUkU50AuEHQ8mmbEw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SiriKit 也強化，Intent 的部分&lt;/li&gt;
  &lt;li&gt;Apple 往「無密碼登入」前進了(Passkeys)，目前我還無法理解機制。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*ZpwryJGDkiv6vSiatuu4Wg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*q9_62GmLnF4LlBbwXWYrqA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MapKit 再強化，你現在可以看到 Map 上細緻到行道樹和人行道，還有多點路徑&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*9mHLFW0Njaft0JPAdeQykw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*3xhgRq56ERGwoInK6iWNiw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WeatherKit。500k / 月 以下呼叫是免費的，接下來天氣 app 會進入血海。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*jAQD9GlhzXYWCNnNEFQZdw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*gJYgR4_XYJzlApHVplYolQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ML / VisionKit 再強化，直接做進 Apple 相機了，接下來貼圖 app 也會進入血海&lt;/li&gt;
  &lt;li&gt;一鍵去背抓主題，已經是 iOS16 內建功能了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*wcZtwyurXrOBVJUMtgUC5Q.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;By &lt;a href=&quot;https://medium.com/@atimis19&quot;&gt;Marvin Lin&lt;/a&gt; on &lt;a href=&quot;https://medium.com/p/a9e361a10a5d&quot;&gt;June 10, 2022&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/wwdc22-keynote-platform-state-of-the-union-a9e361a10a5d&quot;&gt;Canonical link&lt;/a&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="Swift" /><category term="Swift" /><category term="WWDC" /><summary type="html">WWDC 22 開跑啦，這篇節錄 Keynote, Platform State of the union 中和 iOS 開發比較有關的點</summary></entry><entry><title type="html">Meet WeatherKit in WWDC22</title><link href="http://localhost:4000/swift/2022/06/09/Meet-weatherKit-in-WWDC22.html" rel="alternate" type="text/html" title="Meet WeatherKit in WWDC22" /><published>2022-06-09T15:17:00+08:00</published><updated>2022-06-09T15:17:00+08:00</updated><id>http://localhost:4000/swift/2022/06/09/Meet-weatherKit-in-WWDC22</id><content type="html" xml:base="http://localhost:4000/swift/2022/06/09/Meet-weatherKit-in-WWDC22.html">&lt;h1 id=&quot;meet-weatherkit-in-wwdc22&quot;&gt;Meet WeatherKit in WWDC22&lt;/h1&gt;

&lt;p&gt;WWDC22: Meet WeatherKit 重點結錄&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;meet-weatherkit-inwwdc22&quot;&gt;Meet WeatherKit in WWDC22&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*US6DQ8qy70XLbCBAEnQ9sQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;WWDC22: Meet WeatherKit 重點結錄&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2022/10003/&quot; title=&quot;https://developer.apple.com/videos/play/wwdc2022/10003/&quot;&gt;&lt;strong&gt;Meet WeatherKit - WWDC22 - Videos - Apple Developer&lt;/strong&gt;&lt;br /&gt;
_WeatherKit offers valuable weather data for your apps and services to help people stay up to date on the latest…_developer.apple.com&lt;/a&gt;&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2022/10003/&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;提供的資料&quot;&gt;提供的資料&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;現在天氣&lt;/li&gt;
  &lt;li&gt;天氣預報: 日/時/分 等級&lt;/li&gt;
  &lt;li&gt;風向/風力&lt;/li&gt;
  &lt;li&gt;日出/日落/月相&lt;/li&gt;
  &lt;li&gt;歷史天氣資料&lt;/li&gt;
  &lt;li&gt;有更多沒列出來的，都在文件上&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;收費標準-platform-state-of-theunion&quot;&gt;收費標準 (Platform State of the Union)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;500K calls/ month 以下是免費&lt;/li&gt;
  &lt;li&gt;有更高需求的話，也有其他附費方案 1M calls/ Month 定價 $49.99&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*Mqmsvyr6NmcWK-PjcimjYA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;500k 以下免費&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*QsIiuiTd5Abg9lkyr1GgHA.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要有更高流量，也有各種 plan 可選&lt;/p&gt;

&lt;p&gt;可以想見，接下來的 weather app ，會像雨後春筍一般冒出來&lt;/p&gt;

&lt;p&gt;呼叫 WeatherKit 的方法短短幾行就能做到&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import WeatherKitimport CoreLocation

let weatherService = WeatherService()

let syracuse = CLLocation(latitude: 43, longitude: -76)

let weather = try! await weatherService.weather(for: syracuse)

let temperature = weather.currentWeather.temperature

let uvIndex = weather.currentWeather.uvIndex
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Apple 也提供了 RESTful API 的方法呼叫 WeatherKit&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* Request a token */const tokenResponse = await fetch(&apos;&amp;lt;https://example.com/token&amp;gt;&apos;);const token = await tokenResponse.text();

/* Get my weather object */const url = &quot;&amp;lt;https://weatherkit.apple.com/1/weather/en-US/41.029/-74.642?dataSets=weatherAlerts&amp;amp;country=US&amp;gt;&quot;

const weatherResponse = await fetch(url, {headers: {&quot;Authorization&quot;: token}});const weather = await weatherResponse.json();

/* Check for active weather alerts */const alerts = weather.weatherAlerts;const detailsUrl = weather.weatherAlerts.detailsUrl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Apple WeatherKit document&lt;br /&gt;
&lt;a href=&quot;https://developer.apple.com/documentation/weatherkit&quot;&gt;https://developer.apple.com/documentation/weatherkit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By &lt;a href=&quot;https://medium.com/@atimis19&quot;&gt;Marvin Lin&lt;/a&gt; on &lt;a href=&quot;https://medium.com/p/b48aaf4589b2&quot;&gt;June 9, 2022&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/meet-weatherkit-in-wwdc22-b48aaf4589b2&quot;&gt;Canonical link&lt;/a&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="Swift" /><category term="Swift" /><category term="WWDC" /><summary type="html">Meet WeatherKit in WWDC22</summary></entry><entry><title type="html">SwiftUI &amp;amp; Compose</title><link href="http://localhost:4000/swift/2022/06/03/swiftui-and-compose.html" rel="alternate" type="text/html" title="SwiftUI &amp;amp; Compose" /><published>2022-06-03T22:33:38+08:00</published><updated>2022-06-03T22:33:38+08:00</updated><id>http://localhost:4000/swift/2022/06/03/swiftui-and-compose</id><content type="html" xml:base="http://localhost:4000/swift/2022/06/03/swiftui-and-compose.html">&lt;p&gt;Google 的現在正在推 Android study jam 活動，心裡因為好奇，所以也在線上參與了 Study jam 的說明活動。&lt;/p&gt;

&lt;p&gt;詳細的文章我寫在另一篇，可以直接從下方連結過去&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/android-study-jam-%E4%BB%8B%E7%B4%B9-fc2c44dd2f64&quot; title=&quot;https://medium.com/@atimis19/android-study-jam-%E4%BB%8B%E7%B4%B9-fc2c44dd2f64&quot;&gt;&lt;strong&gt;Android Study Jam — 介紹&lt;/strong&gt;&lt;br /&gt;
_Google 官方是很重視 Android 開發環境的，常常會推出不同區域的 Study Jam。這些練習會分成數個階段，當你完成每個階段，都可以拿到徽章，在 2022/06/23 內完成指定的題目後，還會有 Google…_medium.com&lt;/a&gt;&lt;a href=&quot;https://medium.com/@atimis19/android-study-jam-%E4%BB%8B%E7%B4%B9-fc2c44dd2f64&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;在說明會中，我看到 Android 也有一個以宣告式方法，來進行 UI rendering 的框架 — Compose。這個框架可以和 iOS 開發環境中的 SwiftUI 可以進行類比。&lt;/p&gt;

&lt;p&gt;在 Study Jam 說明會中，Tim Lin 示範了用 Compose 畫出一個 Text Label。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*2CZhpAOPfHN_baUdGtkIIA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tim Lin 在 Study jam 中的案例&lt;/p&gt;

&lt;p&gt;於是，我好奇的想，如果我在 SwiftUI 中，使用和 Compose 的排列方式一樣的時候，兩個平台畫出來的東西，會不會一樣呢? (如果會的話….事情就簡單多了)。所以下方就是一個和上面 Compose 一樣順序的 SwiftUI 程式碼。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*EZMuPTxtjvOyFYtkJMgXrg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和上方 Compose 一樣順序的 SwiftUI 程式碼&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*rfx2jRCOGrcDpGyuxpaceA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看渲染的 preview，就會知道，雙方的渲染邏輯不一樣。在 Compose 第一行的 background，會是整個元件的底色(紅色區域)，然後在下一個區域，加上圓角，保留 8 dp 的 padding 後，再畫出黃色區域。&lt;/p&gt;

&lt;p&gt;而 SwiftUI 元件下方第一行的 background，是這個 Text 的 background，然後加上 8 pt 的 padding，再畫上黃色 background。而最後的 4 pt padding，就會產生了 SwiftUI 的白色區域。因為我現在並沒有多的硬碟空間裝 Android Studio 了，所以我目前無法確定 Compose 最外層，或是 Compose 元件套疊的狀況。但 SwiftUI 最後一行的 4pt padding，是有他的意義的，而在沒有多餘顏色下，他會是 default background。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;目前對於 SwiftUI / Compose 都沒有很明確的結論，仍然在研究中。&lt;/p&gt;

&lt;p&gt;也歡迎大家回覆對於這兩個框架的想法。&lt;/p&gt;

&lt;p&gt;Exported from &lt;a href=&quot;https://medium.com&quot;&gt;Medium&lt;/a&gt; on March 14, 2023.&lt;/p&gt;</content><author><name></name></author><category term="Swift" /><summary type="html">Google 的現在正在推 Android study jam 活動，心裡因為好奇，所以也在線上參與了 Study jam 的說明活動。</summary></entry><entry><title type="html">Kotlin Multiplatform Mobile beta roadmap 重點節錄</title><link href="http://localhost:4000/kotlin/cross%20platform/2022/02/04/Kotlin-Multiplatform-mobile-roadmap.html" rel="alternate" type="text/html" title="Kotlin Multiplatform Mobile beta roadmap 重點節錄" /><published>2022-02-04T14:53:00+08:00</published><updated>2022-02-04T14:53:00+08:00</updated><id>http://localhost:4000/kotlin/cross%20platform/2022/02/04/Kotlin-Multiplatform-mobile-roadmap</id><content type="html" xml:base="http://localhost:4000/kotlin/cross%20platform/2022/02/04/Kotlin-Multiplatform-mobile-roadmap.html">&lt;h3 id=&quot;kotlin-multiplatform-mobile-beta-roadmap重點節錄&quot;&gt;Kotlin Multiplatform Mobile beta roadmap 重點節錄&lt;/h3&gt;

&lt;p&gt;在 2021 年 相關團隊發佈了 KMM beta 版本 roadmap 的影片。影片講者 Ekaterina Petrova 提到了數個 Alpha 到 Beta版本改進的內容，主要為&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新的記憶體管理機制&lt;/li&gt;
  &lt;li&gt;與 Apple 開法者想關的整合工具&lt;/li&gt;
  &lt;li&gt;Hierarchical Project 結構調整成預設&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;通常，你只需要針對不同平台的特性，去針對特定平台的 API 進行程式的撰寫。但當使用 KMM 進行共用程式碼開發時，有時候你仍然要對共用程式碼進行不同平台的特化。&lt;/p&gt;

&lt;p&gt;其中一個例子，就是在併發情境下，Alpha 版的 KMM 在記憶體管理上，容易造成問題，且學習曲線陡峭。開發團隊在 2021 年中的時候，就表示未來的 Kotlin (Beta 版) 會在這個方面進行優化。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Apple Integration&lt;/p&gt;

&lt;p&gt;KMM 在 Kotlin 專案的使用，「聽說」已經是相當友善了。而在 Apple 平台，用 embedAndSignAppleFrameworkForXcodeTest 取代以往手動的 packForXcodeTask，此外，還加強了 CocoaPods GradlePlugin DSL 的功能。但這邊有提到，這個 feature 應該會在 Beta release 後進行。&lt;/p&gt;

&lt;p&gt;剩下的 Apple project 整合功能，因為還沒開始測試，所以這邊先不介紹剩下的部分&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;KMM stable for migration&lt;/p&gt;

&lt;p&gt;會在 2022 春季進入 beta，講者說以後會兼顧兼容性，所以應該不用怕大的改動把你的 codebase 搞壞 （Swift 1.0 表示….）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Kotlin Beta roadmap 的影片&lt;/p&gt;

&lt;p&gt;在 jetbrains 的文章&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2021/10/kmm-beta-roadmap-video-highlights/&quot; title=&quot;https://blog.jetbrains.com/kotlin/2021/10/kmm-beta-roadmap-video-highlights/&quot;&gt;&lt;strong&gt;KMM Beta Roadmap Video Highlights | The Kotlin Blog&lt;/strong&gt;&lt;br /&gt;
_The Kotlin 2021 Premier Online Event is in full swing, and The KMM Beta Roadmap video is already available for you to…_blog.jetbrains.com&lt;/a&gt;&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2021/10/kmm-beta-roadmap-video-highlights/&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By &lt;a href=&quot;https://medium.com/@atimis19&quot;&gt;Marvin Lin&lt;/a&gt; on &lt;a href=&quot;https://medium.com/p/60f673b3eda7&quot;&gt;February 4, 2022&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/kotllin-multiplatform-mobile-beta-roadmap-%E9%87%8D%E9%BB%9E%E7%AF%80%E9%8C%84-60f673b3eda7&quot;&gt;Canonical link&lt;/a&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="[&quot;Kotlin&quot;, &quot;Cross platform&quot;]" /><category term="KMM" /><category term="kotlin" /><category term="cross platform" /><summary type="html">Kotlin Multiplatform Mobile beta roadmap 重點節錄</summary></entry><entry><title type="html">Stripe 系統漸進式升級的過程</title><link href="http://localhost:4000/system%20design/2021/12/18/Stripe-system-migrate.html" rel="alternate" type="text/html" title="Stripe 系統漸進式升級的過程" /><published>2021-12-18T15:11:00+08:00</published><updated>2021-12-18T15:11:00+08:00</updated><id>http://localhost:4000/system%20design/2021/12/18/Stripe-system-migrate</id><content type="html" xml:base="http://localhost:4000/system%20design/2021/12/18/Stripe-system-migrate.html">&lt;p&gt;歷史上，如果火車的軌道寬度要升級，並不會在原來的鐵道上多鋪上兩條鐵軌，而是多蓋一條鐵軌，讓不同軌距的火車，都可以同時行駛在軌道上。等到其中一種軌距的火車全數被汰換掉，這時才會把不用的軌道拆掉。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;stripe-系統漸進式升級的過程&quot;&gt;Stripe 系統漸進式升級的過程&lt;/h3&gt;

&lt;p&gt;歷史上，如果火車的軌道寬度要升級，並不會在原來的鐵道上多鋪上兩條鐵軌，而是多蓋一條鐵軌，讓不同軌距的火車，都可以同時行駛在軌道上。等到其中一種軌距的火車全數被汰換掉，這時才會把不用的軌道拆掉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*kVy_4E7Jw81-keZ1SwVu1g.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;stripe-進行過的-online-migrations&quot;&gt;Stripe 進行過的 online migrations&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://stripe.com/blog/online-migrations&quot; title=&quot;https://stripe.com/blog/online-migrations&quot;&gt;&lt;strong&gt;Online migrations at scale&lt;/strong&gt;&lt;br /&gt;
_Jacqueline Xu on February 2, 2017 in Engineering Engineering teams face a common challenge when building software: they…_stripe.com&lt;/a&gt;&lt;a href=&quot;https://stripe.com/blog/online-migrations&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以下是在讀完 Stripe 文章後的整理&lt;/p&gt;

&lt;p&gt;線上付款為主要業務，如果你想要有海外收款能力，直接找 Stripe 比去和當地銀行快很多。而且要拓展不同國家的業務，大部分都可以在 Stripe 上完成。&lt;/p&gt;

&lt;p&gt;誠實蜜蜂的線上收款方案之一，就是 Stripe。&lt;/p&gt;

&lt;p&gt;為什麼是「之一」? 因為當時營運的七個亞洲國家中，有幾個不在 Stripe 業務範圍內，所以又引入了另一個收款第三方平台。&lt;/p&gt;

&lt;h3 id=&quot;stripe-的使用者數量級&quot;&gt;Stripe 的使用者數量級&lt;/h3&gt;

&lt;p&gt;文章中提到的是 Subscription object，有可能這些 object 為單一公司行號。數量為 hundred millions，所以在 2017 年的時候，在數億左右。&lt;/p&gt;

&lt;p&gt;這些數億量級的資料，被放在 table 中，且在 code base 中數個地方大量使用。&lt;/p&gt;

&lt;p&gt;且金流服務是不能斷的，所以 Stripe 使用的 migration 一定是 online 的。&lt;/p&gt;

&lt;h3 id=&quot;online-migration-pattern四步驟&quot;&gt;Online migration pattern — 四步驟&lt;/h3&gt;

&lt;p&gt;1: &lt;strong&gt;Dual writing&lt;/strong&gt; to the existing and new tables to keep them in sync.&lt;/p&gt;

&lt;p&gt;要對現有 table 和新的 table 都寫入一樣的資料&lt;/p&gt;

&lt;p&gt;2: &lt;strong&gt;Changing all read paths&lt;/strong&gt; in our codebase to read from the new table.&lt;/p&gt;

&lt;p&gt;換掉所有的讀取路徑&lt;/p&gt;

&lt;p&gt;3: &lt;strong&gt;Changing all write paths&lt;/strong&gt; in our codebase to only write to the new table.&lt;/p&gt;

&lt;p&gt;換掉所有的寫入路徑&lt;/p&gt;

&lt;p&gt;4: &lt;strong&gt;Removing old data&lt;/strong&gt; that relies on the outdated data model&lt;/p&gt;

&lt;p&gt;移除掉舊的資料(應該是封存)&lt;/p&gt;

&lt;h3 id=&quot;migration-example&quot;&gt;Migration example&lt;/h3&gt;

&lt;h3 id=&quot;最初的商業邏輯&quot;&gt;最初的商業邏輯&lt;/h3&gt;

&lt;p&gt;每個客戶都會有 Subscription，但最初只設計了一個&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Customer  Subscription subscriptionend
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是，隨著業務愈做愈多，客戶需求愈來愈複雜。&lt;/p&gt;

&lt;p&gt;折價券，折扣，invoice 等功能被加進來， subscription 就要變成 subscriptions&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Customer  array: Subscription subscriptionsend
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而當客戶成長到了一定程度，就要做資料庫的切分，可回頭看 CH6。&lt;/p&gt;

&lt;p&gt;左邊是既有設計，右邊是要 migration 的架構&lt;/p&gt;

&lt;p&gt;再回頭看一次，migration pattern 四步驟&lt;/p&gt;

&lt;p&gt;1: &lt;strong&gt;Dual writing&lt;/strong&gt; to the existing and new tables to keep them in sync.&lt;/p&gt;

&lt;p&gt;2: &lt;strong&gt;Changing all read paths&lt;/strong&gt; in our codebase to read from the new table.&lt;/p&gt;

&lt;p&gt;3: &lt;strong&gt;Changing all write paths&lt;/strong&gt; in our codebase to only write to the new table.&lt;/p&gt;

&lt;p&gt;4: &lt;strong&gt;Removing old data&lt;/strong&gt; that relies on the outdated data model&lt;/p&gt;

&lt;h3 id=&quot;part1-dual-writing雙重寫入&quot;&gt;part1: Dual writing 雙重寫入&lt;/h3&gt;

&lt;p&gt;只要有新的寫入，就會有一隻程式發動，把這個 subscription 的資料，移到新的 table&lt;/p&gt;

&lt;p&gt;然後，再進行 backfilling，把以前的資料倒進新 table&lt;/p&gt;

&lt;p&gt;Stripe 使用 Scalding 套件來進行 backfilling，看文章是建講在 Hadoop cluster 上，所以也有使用 MapReduce 進行。而且，只需要約十行程式碼。&lt;/p&gt;

&lt;p&gt;Scalding is a useful library written in Scala that makes it easy to write MapReduce jobs (you can write a simple one in 10 lines of code).&lt;/p&gt;

&lt;p&gt;Backfilling 的步驟如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Write a Scalding job that provides a list of all subscription IDs that need to be copied over. (找出所有要被 Copy 的 IDs)&lt;/li&gt;
  &lt;li&gt;Run a large, multi-threaded migration to duplicate these subscriptions with a fleet of processes efficiently operating on our data in parallel. (使用多緒的程式開始處理 migration)&lt;/li&gt;
  &lt;li&gt;Once the migration is complete, run the Scalding job once again to make sure there are no existing subscriptions missing from the Subscriptions table. (結束後，使用 Scalding 進行檢查，看有無缺漏)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;part2-changing-all-read-paths改掉所有讀取路徑&quot;&gt;part2: Changing all read paths — 改掉所有讀取路徑&lt;/h3&gt;

&lt;p&gt;前一個動作，已經讓新舊的 table 同步了，現在要改掉讀取路徑，原來舊的讀取路徑都要換成新的路徑。&lt;/p&gt;

&lt;p&gt;為了確保新的 subscriptions table 讀到的東西都是正確的(和舊 table 一樣)，stripe 使用了 Scientist 的套件來驗證這一行為。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/github/scientist&quot;&gt;https://github.com/github/scientist&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Scientist 是 Ruby library 中，拿來做實驗比對結果的，這個套件會讀新的表和舊的表，並把值交互比對，如果不同，他就發出 error alerting。&lt;/p&gt;

&lt;p&gt;在確認新舊表完全相同之後，就會把讀取路徑切到新的 subscriptions table 中。&lt;/p&gt;

&lt;h3 id=&quot;part3-changing-all-write-paths改掉所有寫入路徑&quot;&gt;part3: Changing all write paths — 改掉所有寫入路徑&lt;/h3&gt;

&lt;p&gt;下面是 part1 的寫入路徑，那時候設定為 dual write&lt;/p&gt;

&lt;p&gt;現在狀況， dual write 會將資料先寫進舊的 customers 表，然後再寫入 subscriptions 表。在 Changing all write paths 這一步，我們要將寫入順序倒轉，先寫入 Subscriptions 再寫入 customers. 注意這一步並不是直接拿掉 customers 表的寫入，而是倒轉。這樣我們才能在改動過程中，進行觀察，並防止重大錯誤在不知情的狀況下持續。&lt;/p&gt;

&lt;p&gt;更換寫入路徑，是 migration 最大的挑戰。在 Stripe 裡面，已經有上千行的程式碼和 subscription 有關，這些程式碼也四散在各個 service 中。&lt;/p&gt;

&lt;p&gt;為了逐步確認每個步驟都是正確的，在重構的過程中，Stripe 將程式的路徑儘可能切到最小的單位，一步一步的抽換，確保新舊的表是同步。&lt;/p&gt;

&lt;p&gt;在抽換的時候，一定要非常，非常小心的應對。Stripe 是不可以直接將新 records 蓋掉舊 records。只要有 miss，就會造成 data inconsistency。而抽換前後的資料確認， Stripe 也是用了 Scientist 套件中提供的功能，進行實驗(experiments 應該是這個 lib 的功能)&lt;/p&gt;

&lt;p&gt;最後，抽換的結果如下。&lt;/p&gt;

&lt;p&gt;最後，在 Customer 物件中，寫上 raise error，只要有人呼叫原來的 subscriptions，就會 raising an error&lt;/p&gt;

&lt;p&gt;最後，在 Customer 物件中，寫上 raise error，只要有人呼叫原來的 subscriptions，就會 raising an error&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Customer  def subscriptions    Opus::Error.hard(&quot;Accessing subscriptions array on customer&quot;)  endend
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;part4: &lt;strong&gt;Removing old data — 將舊資料移除掉&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最後一步，移除掉把寫進舊 table 的程式碼移除掉，最後最後，就會真的刪掉這些程式碼 (你有在用版本控制，不用怕刪程式碼)&lt;/p&gt;

&lt;p&gt;等到確認所有的程式碼，都只從 subscriptions 的表拿資料，那就可以把送資料進舊表的程式碼拿掉了。&lt;/p&gt;

&lt;p&gt;最後，就完成轉移， subscriptions 的資料，就會從新表拿。&lt;/p&gt;

&lt;p&gt;By &lt;a href=&quot;https://medium.com/@atimis19&quot;&gt;Marvin Lin&lt;/a&gt; on &lt;a href=&quot;https://medium.com/p/d2c7e73e298b&quot;&gt;December 18, 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/stripe-%E7%B3%BB%E7%B5%B1%E6%BC%B8%E9%80%B2%E5%BC%8F%E5%8D%87%E7%B4%9A%E7%9A%84%E9%81%8E%E7%A8%8B-d2c7e73e298b&quot;&gt;Canonical link&lt;/a&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="system design" /><category term="system design" /><category term="migration" /><summary type="html">歷史上，如果火車的軌道寬度要升級，並不會在原來的鐵道上多鋪上兩條鐵軌，而是多蓋一條鐵軌，讓不同軌距的火車，都可以同時行駛在軌道上。等到其中一種軌距的火車全數被汰換掉，這時才會把不用的軌道拆掉。</summary></entry><entry><title type="html">資料密集型應用系統設計-第六章筆記</title><link href="http://localhost:4000/system%20design/2021/11/02/data-intensive-applications.html" rel="alternate" type="text/html" title="資料密集型應用系統設計-第六章筆記" /><published>2021-11-02T15:01:00+08:00</published><updated>2021-11-02T15:01:00+08:00</updated><id>http://localhost:4000/system%20design/2021/11/02/data-intensive-applications</id><content type="html" xml:base="http://localhost:4000/system%20design/2021/11/02/data-intensive-applications.html">&lt;p&gt;這世界上沒有銀色子彈 https://g.co/kgs/G7QbDr&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;資料密集型應用系統設計-第六章筆記&quot;&gt;資料密集型應用系統設計-第六章筆記&lt;/h3&gt;

&lt;p&gt;這世界上沒有銀色子彈 &lt;a href=&quot;https://g.co/kgs/G7QbDr&quot;&gt;https://g.co/kgs/G7QbDr&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*ifN_ysbEQV3aPal21VYuXQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;為什麼需要分區&quot;&gt;為什麼需要分區?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;可擴充性增加&lt;/li&gt;
  &lt;li&gt;只要業務量增加，最終單一伺服器總會遇到上限，在需要擴增的狀況下，選擇適當的分區策略，對未來的業務會有更大的助益。&lt;/li&gt;
  &lt;li&gt;增加效率&lt;/li&gt;
  &lt;li&gt;當分區策略做的好，在查找的效率會提高。&lt;/li&gt;
  &lt;li&gt;增加安全性&lt;/li&gt;
  &lt;li&gt;在特定狀況，可以將資料分成敏感性和非敏感性，分開存放。並在前面放上 security control，在不同&lt;/li&gt;
  &lt;li&gt;增加操作的彈性&lt;/li&gt;
  &lt;li&gt;因為不只一個儲存資料的地方，就可以有更多可優化的方法。像是 management, monitoring, backup and restore&lt;/li&gt;
  &lt;li&gt;讓資料的本質更貼近儲存的型別&lt;/li&gt;
  &lt;li&gt;分區是可以依照資料類型而分的。對於大的 binary data 的資料，放進對 blob storage 有優化的區，比放在 document database 更好。&lt;/li&gt;
  &lt;li&gt;增加可靠性&lt;/li&gt;
  &lt;li&gt;分區可以避免 single point of failure 等情形。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;分區的策略&quot;&gt;分區的策略&lt;/h3&gt;

&lt;h3 id=&quot;水平分區-horizontal-partitioning&quot;&gt;水平分區 Horizontal partitioning&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*aLGFA24i3vdS5Fioh3SCKg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每個分區分掉一部分的資料，這個策略中比較好的策略是讓每個分區對系統的負擔是差不多。每個分區擁有相同的 schema。每個分區也被稱之為 shard 。&lt;/p&gt;

&lt;p&gt;水平分區的舉例，會將分區依照 key 的字母順序排列。這個策略最重要的是決定 sharding key 的範圍，因為策略一但執行並上線之後，就很難再度調整。&lt;/p&gt;

&lt;p&gt;但這並不表示應該讓每個分區所擁有的「數量」一樣，在書本上的例子，是用百科全書為例。但是百科全書是個出版品，如果出版社想讓每本書的厚度相近，就會設計的讓頁數相近，所以排列的方法是讓字母順序的分區，能讓分區後的詞類和解釋的數量相近。&lt;/p&gt;

&lt;p&gt;但是就資料庫而言，並不單純是「擁有的資料」，也有可能依照現實情境設計。可以設計成某個 shards 擁有的資料很大，但每個 item 的讀/寫頻率很低。而其他分區擁有的資料很小，但是讀/寫頻率很高。&lt;/p&gt;

&lt;p&gt;要注意的點:&lt;/p&gt;

&lt;p&gt;要確保每一個 shard 不會超過機器的物理上限。&lt;/p&gt;

&lt;p&gt;需要避免製造出會影響效能或可靠近的「熱區」，舉例來說，如果設計讓顧客的首字字母當做分區的 Key 分類，就會造成某些分佈不均，因為人類的語言上會有常用習慣。可以替代的方案，就是先經過 hash 函數，再分散放入分區中。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;垂直分區-vertical-partitioning&quot;&gt;&lt;strong&gt;垂直分區 Vertical partitioning&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*XXjsPN9UtOCuhKUV9Bj7HA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每個分區都擁是原始資料的子集合。舉例來說，將欄位分成常用和不常用的部分，常用的欄位放在某一分區，不常用的放另一分區。&lt;/p&gt;

&lt;p&gt;縱向分區最常使用的場景，就是減少 I/O 和降低高頻率拉取資料的成本。&lt;/p&gt;

&lt;p&gt;以上 Fig2 為例，一個分區存放高頻率被存取的資料，包含產品名稱，描述，價格。另一個分區存放的資料，是倉庫中的庫存和上次訂購的時間。在這個例子中，這個系統常常會因為 App 需要顯示，而要去 query 產品名稱、描述、價格。&lt;/p&gt;

&lt;p&gt;而庫存數量和上次購買日期會放在一區，是因為這兩個 item 常常一起在同一個區段顯示。&lt;/p&gt;

&lt;p&gt;其他優點&lt;/p&gt;

&lt;p&gt;不常變更的項目，和常常變更的項目會切開。在這個例子中，產品名稱，描述，價格是不常變動項目。而庫存數目和上次購買日期是常常變動的項目。而不常變動項目的區間，是很容易被選到放在記憶體中的快取。&lt;/p&gt;

&lt;p&gt;敏感型資料可以分區存放，並加上 additional security controls。&lt;/p&gt;

&lt;p&gt;垂直分區可以減少所需的併發型 access。以上面的例子來說，如果當 client 真的發生訂購行為，會更動庫存和上次購買時間。垂直分區的策略，不會讓整條 row 鎖住。而這個策略，也因為只要特定欄位，在 MSSql 以 Page 為單位時，每個 Page 可包含的 row 數量會比使用水平分區策略的多。&lt;/p&gt;

&lt;p&gt;功能分區 Functional partitioning (Microsoft 的文章)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*MUsz-zJi4R9v_hZRYzaacw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;功能分區。將資料依照「如何被使用」來分，舉例來說，如果架設電商系統的分區，會將產品庫存資料放在一個分區，而發票/收據資料，放在另一個分區。&lt;/p&gt;

&lt;p&gt;如果商業邏輯的邊界是很明顯的，那依照功能切分是可以提升效率的。常用的場景是，將 read-write data 和 read-only data 放在不同區分。在 Fig 3 中的場景，是將庫存資料和客戶資料放在不同區分。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;key-or-hashed-basesharding&quot;&gt;Key or hashed base sharding&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*Fac4H-wdk02et48Lm9thiw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假設你有四台 database servers，每個 request 都有 application id。只要使用 hash 和 mod ，就能將資料分散到四台機器上。&lt;/p&gt;

&lt;p&gt;這個方法的主要缺點是， elastic load balancing (dynamically adding/removing database servers) 會非常困難，而且成本很高。&lt;/p&gt;

&lt;p&gt;假設，你想要多加六台機器，就必需進行 remapp 和 migration。除此之外，你還要調整你的 hash function，從 mod 4 變成 mod 10。&lt;/p&gt;

&lt;p&gt;現在，是有不停機的轉換的方式，如 Consistant Hashing，參考資料如下。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acodersjourney.com/system-design-interview-consistent-hashing/&quot;&gt;https://www.acodersjourney.com/system-design-interview-consistent-hashing/&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;directory-basedsharding&quot;&gt;Directory based sharding&lt;/h3&gt;

&lt;p&gt;Directory based shard 分區會在分區前面加上 lookup service。lookup service 知道現在的分區 scheme，並在系統中留存一份 map 紀錄。&lt;/p&gt;

&lt;p&gt;client 端會先去問 lookup service，去找出 entity 是被放在哪個 shard，然後才會進行查找的動作。&lt;/p&gt;

&lt;p&gt;優點&lt;/p&gt;

&lt;p&gt;可以解決 elastic scaling 問題，而且是在不使用 consistent hashing 的前提。先假設前面的擴張情況，四個 database service 配上 hashed based 區分策略。現在要加上六個 database servers 而且不想停機。&lt;/p&gt;

&lt;p&gt;步驟如下&lt;/p&gt;

&lt;p&gt;1&amp;gt; lookup service 仍然使用 mod 4 hash function&lt;/p&gt;

&lt;p&gt;2&amp;gt; 先區分出，如果在 mod 10 的狀況下，資料該怎麼區分&lt;/p&gt;

&lt;p&gt;3&amp;gt; 寫一段 script 把所有的資料 copy 到新的六台 shards 上，注意，此時並不會刪掉原來四台上的資料。&lt;/p&gt;

&lt;p&gt;4&amp;gt; 當 copy 完成，換掉 lookup service 上的 hash function，從 mod 4 換成 mod 10。&lt;/p&gt;

&lt;p&gt;5&amp;gt; 將 4 台舊資料上的資料清掉 (稱之為 purge 或 clean up)。&lt;/p&gt;

&lt;p&gt;在實務上要注意的地方&lt;/p&gt;

&lt;p&gt;migration 時，使用者還是有可能在更新資料。可能的解法，將系統轉為 read-only mode。或是先將這個時間的資料，放到另一個 service 上，等到 migration 結束再移回來。&lt;/p&gt;

&lt;p&gt;copy 和 clean up 對效能會有很大影響。可能解法就是 cloning and elastic load balancing，但這兩個方法的成本都很高&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;參考文章&quot;&gt;參考文章&lt;/h3&gt;

&lt;p&gt;分區的文章&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acodersjourney.com/database-sharding/&quot;&gt;https://www.acodersjourney.com/database-sharding/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Consistent Hashing&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acodersjourney.com/system-design-interview-consistent-hashing/&quot;&gt;https://www.acodersjourney.com/system-design-interview-consistent-hashing/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Microsoft 對工作負載和熱點降溫&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/best-practices/data-partitioning&quot;&gt;https://docs.microsoft.com/en-us/azure/architecture/best-practices/data-partitioning&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By &lt;a href=&quot;https://medium.com/@atimis19&quot;&gt;Marvin Lin&lt;/a&gt; on &lt;a href=&quot;https://medium.com/p/c8b1ddc94554&quot;&gt;November 2, 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/designing-data-intensive-applications-notes-c8b1ddc94554&quot;&gt;Canonical link&lt;/a&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="system design" /><category term="system design" /><summary type="html">這世界上沒有銀色子彈 https://g.co/kgs/G7QbDr</summary></entry><entry><title type="html">使用 Turi Create 製作圖案辨識的 App - Core ML and Vision</title><link href="http://localhost:4000/swift/2018/08/20/Using-Turi-create-make-an-app.html" rel="alternate" type="text/html" title="使用 Turi Create 製作圖案辨識的 App - Core ML and Vision" /><published>2018-08-20T15:32:00+08:00</published><updated>2018-08-20T15:32:00+08:00</updated><id>http://localhost:4000/swift/2018/08/20/Using-Turi-create-make-an-app</id><content type="html" xml:base="http://localhost:4000/swift/2018/08/20/Using-Turi-create-make-an-app.html">&lt;p&gt;使用 Turi Create 製作圖案辨識的 App - Core ML and Vision * { font-family: Georgia, Cambria, “Times New Roman”, Times, serif; } html, body { margin: 0; padding: 0; } h1 { font-size: 50px; margin-bottom: 17px; color: #333; } h2 { font-size: 24px; line-height: 1.6; margin: 30px 0 0 0; margin-bottom: 18px; margin-top: 33px; color: #333; } h3 { font-size: 30px; margin: 10px 0 20px 0; color: #333; } header { width: 640px; margin: auto; } section { width: 640px; margin: auto; } section p { margin-bottom: 27px; font-size: 20px; line-height: 1.6; color: #333; } section img { max-width: 640px; } footer { padding: 0 20px; margin: 50px 0; text-align: center; font-size: 12px; } .aspectRatioPlaceholder { max-width: auto !important; max-height: auto !important; } .aspectRatioPlaceholder-fill { padding-bottom: 0 !important; } header, section[data-field=subtitle], section[data-field=description] { display: none; }&lt;/p&gt;

&lt;h1 id=&quot;使用-turi-create-製作圖案辨識的-app---core-ml-and-vision&quot;&gt;使用 Turi Create 製作圖案辨識的 App - Core ML and Vision&lt;/h1&gt;

&lt;p&gt;Turi Create是一個拿來做 machine learning model 的 Python 模組，在 WWDC18 上，有多個 Session 直接在現場使用這個模組直接 Demo。他可以讓 iOS 開發者在使用 Core ML 模組時，更專注在 APIs…&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;使用-turi-create-製作圖案辨識的-app---core-ml-andvision&quot;&gt;使用 Turi Create 製作圖案辨識的 App - Core ML and Vision&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/0*azSEH7drAK07vjkT&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“A person’s hand holding a camera lens over a mountain lake” by &lt;a href=&quot;https://unsplash.com/@pawelskor?utm_source=medium&amp;amp;utm_medium=referral&quot;&gt;Paul Skorupskas&lt;/a&gt; on &lt;a href=&quot;https://unsplash.com?utm_source=medium&amp;amp;utm_medium=referral&quot;&gt;Unsplash&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Turi Create是一個拿來做 machine learning model 的 Python 模組，在 WWDC18 上，有多個 Session 直接在現場使用這個模組直接 Demo。他可以讓 iOS 開發者在使用 Core ML 模組時，更專注在 APIs 的行為上。除些之外，你如果有些初步的想法，你不用去找一個 ML 專家或是把自己變成 ML 專家，也能做出一個初步的 ML Model，讓這個 model 先做 prototype 再發揚光大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 WWDC18 Session 712 中，整個 session 都在介紹 Turi Create，如果對那個 Session 有興趣，你可以看下面這一篇 Medium。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/overview-of-wwdc18-session-712-turi-create-build-an-app-with-core-ml-is-not-that-difficult-a46cb9420b34&quot; title=&quot;https://medium.com/@atimis19/overview-of-wwdc18-session-712-turi-create-build-an-app-with-core-ml-is-not-that-difficult-a46cb9420b34&quot;&gt;&lt;strong&gt;WWDC18, Session-712 Turi Create 重點整理 -製作ML model 不再是一個困難的事&lt;/strong&gt;&lt;br /&gt;
_Turi Create 是什麼?_medium.com&lt;/a&gt;&lt;a href=&quot;https://medium.com/@atimis19/overview-of-wwdc18-session-712-turi-create-build-an-app-with-core-ml-is-not-that-difficult-a46cb9420b34&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;讓我們開始 Demo Turi Create 裡面會用到的 API，以及他怎麼實作吧。我們要實作的是判斷這張圖裡面是不是金城武。範例影片放在這個 Youtube 上，除了判斷是不是金城武以外，還加上了信心指數。&lt;/p&gt;

&lt;p&gt;信心指數的意思，你的 model 對這個結果有多少的信心，這個數字會在 0~ 1.0 之間。如果他判斷這張圖不是金城武，然後信心指數是 0.97。就表示這個 data 對這個 model來說，「不是金城武」這結果有 0.97 的信心指數。&lt;/p&gt;

&lt;p&gt;要做 image classification 前，你需要有 image data，然後針對該分類建立資料夾，並把對應的圖片放到資料夾內。當然資料是愈多愈好，但至少該放多少呢?蘋果的投影片中有提到，建議至少放個 40 張當做 data。&lt;/p&gt;

&lt;p&gt;如下圖所示，我在網路上搜尋了 40 張金城武的照片，然後放進 kaneshiro 這個資料夾。不過比較困難的地方，是「非金城武」這邊的 data 應該放什麼呢? 就邏輯來說，就是放所有非金城武的照片，但這些照片到底該放哪些呢? 因為是範例，所以我這裡就先放數十張非金城武的人像照當做 demo ，真正在做這種專案的時候，還是建議詢問資料科學領域的人，你想處理的資料該怎麼訓練模型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*VMSfkj3qJ7fyl2Eo4bGSLw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在 dataset 內放 kaneshiro的照片,unknown 則放不是目標的照片&lt;/p&gt;

&lt;p&gt;當你的資料放好了，你就可以用下面這些程式碼進行 model 的訓練和 Core ML 的輸出。程式碼的數量相當的低，這邊只用了 12 行而已 (註解不算)。你可以在 (Ref-1) 上直接下載 Jupyter Notebook 的檔案&lt;/p&gt;

&lt;p&gt;Turi Create 在讀取檔案的時候非常聰明，如果他讀的案是他不支援的，他會吐出 error message，但程式會繼續執行。下圖示範了這個結果，.DS_Store 是 mac 系統裡面存放空間資料用途，這是給 Mac OS 的 finder 程式使用的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*t0JaxQccx312PWr5GRGLHQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;讀到不是JPEG和PNG 以外的檔案會跳過&lt;/p&gt;

&lt;p&gt;如果你的 Jupyter Notebook 是第一次跑，程序會連到 Apple 的 model 網站去下載相關資料。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*6t9nmsXsDbavxS3lYYbpnQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Message 的 downloading 就是連到Apple網站去下載模型資料&lt;/p&gt;

&lt;p&gt;下面就是模型訓練時， Turi Create 會吐出來的資訊&lt;/p&gt;

&lt;p&gt;Analyzing and extracting image features.&lt;/p&gt;

&lt;p&gt;+——————+————–+——————+&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Images Processed&lt;/td&gt;
      &lt;td&gt;Elapsed Time&lt;/td&gt;
      &lt;td&gt;Percent Complete&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;+——————+————–+——————+&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;3.16s&lt;/td&gt;
      &lt;td&gt;50%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;74&lt;/td&gt;
      &lt;td&gt;11.34s&lt;/td&gt;
      &lt;td&gt;100%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;+——————+————–+——————+&lt;/p&gt;

&lt;p&gt;Logistic regression:&lt;/p&gt;

&lt;p&gt;-——————————————————-&lt;/p&gt;

&lt;p&gt;Number of examples          : 74&lt;/p&gt;

&lt;p&gt;Number of classes           : 2&lt;/p&gt;

&lt;p&gt;Number of feature columns   : 1&lt;/p&gt;

&lt;p&gt;Number of unpacked features : 2048&lt;/p&gt;

&lt;p&gt;Number of coefficients      : 2049&lt;/p&gt;

&lt;p&gt;Starting L-BFGS&lt;/p&gt;

&lt;p&gt;-——————————————————-&lt;/p&gt;

&lt;p&gt;+———–+———-+———–+————–+——————-+&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Iteration&lt;/td&gt;
      &lt;td&gt;Passes&lt;/td&gt;
      &lt;td&gt;Step size&lt;/td&gt;
      &lt;td&gt;Elapsed Time&lt;/td&gt;
      &lt;td&gt;Training Accuracy&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;+———–+———-+———–+————–+——————-&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;0.017910&lt;/td&gt;
      &lt;td&gt;0.540541&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0.000083&lt;/td&gt;
      &lt;td&gt;0.125282&lt;/td&gt;
      &lt;td&gt;0.540541&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;5.000000&lt;/td&gt;
      &lt;td&gt;0.181402&lt;/td&gt;
      &lt;td&gt;0.918919&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;5.000000&lt;/td&gt;
      &lt;td&gt;0.207410&lt;/td&gt;
      &lt;td&gt;0.945946&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;5.000000&lt;/td&gt;
      &lt;td&gt;0.242203&lt;/td&gt;
      &lt;td&gt;0.459459&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;0.280374&lt;/td&gt;
      &lt;td&gt;0.864865&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;0.409511&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;+———–+———-+———–+————–+——————-+&lt;/p&gt;

&lt;p&gt;Completed (Iteration limit reached).&lt;/p&gt;

&lt;p&gt;This model may not be optimal. To improve it, consider increasing `max_iterations`.&lt;/p&gt;

&lt;p&gt;Analyzing and extracting image features.&lt;/p&gt;

&lt;p&gt;+——————+————–+——————+&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Images Processed&lt;/td&gt;
      &lt;td&gt;Elapsed Time&lt;/td&gt;
      &lt;td&gt;Percent Complete&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;+——————+————–+——————+&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;2.53s&lt;/td&gt;
      &lt;td&gt;100%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;+——————+————–+——————+&lt;/p&gt;

&lt;p&gt;1.0&lt;/p&gt;

&lt;p&gt;我個人覺得這個模組很棒的地方，是他會提示你這個模型是不是需要再修正。像上面的 message 中可以看到一行: &lt;strong&gt;This model may not be optimal. To improve it, consider increasing `max_iterations`&lt;/strong&gt;. 這是因為我 max_iterations 只給預設值，結果他跑出來後覺得這個模型準確率太低，並直接建議你調高 max_iterations。&lt;/p&gt;

&lt;p&gt;跑完後你就可以拿到 mlmodel 這個檔案，而且你還可以看到 model 細項。以本文為例，你可以看到他有說明這個是 mlmodel 是用於 image clasifier，而且是從 Resnet-50 訓練出來的， Turi Create 版本是 5.0 beta 3。&lt;/p&gt;

&lt;p&gt;底下則是 input 和 output 訊息，你要輸入的是彩色 224 x 224 的圖片。然後他輸出有兩個，如果是 kaneshiroOrNot，則是這個 model 判出來的結果。因為當初我們只設定兩個 label，一個是 Kaneshiro，另一個是 Unknown。所以這一項一定是這兩個其一。&lt;/p&gt;

&lt;p&gt;另一個輸出是 kaneshiroOrNotProbability 他是個 dictionary，key 是每個 label，value 是該 label 的信心指數，雖然這個範例只有兩個 label ，但實際上你能訓練出能辨試多種水果的 model，這時候你可能會想知道每個 label 的信心指數，去看有沒有可能有近似的結果，再去做處理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*v4W8f-kJWTirPfbDiKU77g.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*np33KUxG7F-Q6MA50KxbVQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;mlmodel 的細項，這包含用什麼模型做訓練，以及輸入的格式，輸出的格式。以本文為，輸出有兩項kaneshiroOrNot 輸出一個string,是指他判斷出來的 label。另一個則是每一項的信心值數字。&lt;/p&gt;

&lt;p&gt;接下來，我們開始寫圖像辨識的專案吧。因為這個專案極有可能用到照相機和相簿功能，請記得在 info.plist 裡面做 Privacy 請求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*XtZzzm2T_CwVxDkaw1iq9Q.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;請記得在 info.plist內做這兩個功能要求&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;在這裡，我先使用 App Coda 的方法 (Ref-2)讓 ML Model 去讀取 UIImage 檔案。我也試用過 Vision 模組的 VNRequest，但辨識的結果差很多，而且該檔案和模組都是直接從 Apple 上下載下來的。我想，可能還有些參數我應該要調整才能讓辨識率提高。目前 App Coda 的這個方法，辨識率還不錯，就先用這種方式。&lt;/p&gt;

&lt;p&gt;在 UIImage 裡面 extension buffer 這個 method。讓原來的 image data 專換成 VCPixelBuffer 格式， Core ML 模組才能辨識。&lt;/p&gt;

&lt;p&gt;UIImage extension 後，讓 image 直接轉換成 CVPixelBuffer&lt;/p&gt;

&lt;p&gt;接下來就是辨識的核心 method。因為我們的 MLModel 是基於 Resnet 所訓練出來的，所以他吃的是 224 x 224 的 image，這個資訊你可以在 MLModel file detail 看到。&lt;/p&gt;

&lt;p&gt;接下來，只要在取得 image 物件後，去呼叫 judgeKaneshiro(:)，就完成了。舉例來說，像是鏡頭取得 image 後。&lt;/p&gt;

&lt;p&gt;func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any])&lt;/p&gt;

&lt;p&gt;實際跑一遍，你會發現，這個範例並沒有那麼準，比如說，有幾張金城武的照片，因為髮型或者背景不一樣，他就認為這不是金城武。然後，我也試著把古天樂放進去判斷看看，結果他認為這個是金城武。這樣的問題並沒有辦法在這裡用程式碼解決，因為這是 mlmodel 判斷的結果。要處理的話，要從訓練 model 那邊開始下手。建議你可以試著換換 model，或是調整 dataset，或是調一下 max_iterations 參數試試看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*Ijy0jbkDKPJ7-V6uDpWZxg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;雖然大部分的照片都可以分得出來&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*VEGL3cEQmOwVsWH3Xu-6Gg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是仍然有判錯的情況，古天樂被當成金城武了，而且髮型改變比較大，就認不出來了&lt;/p&gt;

&lt;p&gt;整個專案都放在下面這個 GitHub ，你可以在 Project_KaneshiroOrNot 中找到 XCode 的檔案。Turi Create 的程式碼則可以在 Jupyter Notebook 的 folder 中找到。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Ref-1: GitHub位址&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/MoonAndEye/TuriCreateDemo&quot; title=&quot;https://github.com/MoonAndEye/TuriCreateDemo&quot;&gt;&lt;strong&gt;MoonAndEye/TuriCreateDemo&lt;/strong&gt;&lt;br /&gt;
_GitHub is where people build software. More than 28 million people use GitHub to discover, fork, and contribute to over…_github.com&lt;/a&gt;&lt;a href=&quot;https://github.com/MoonAndEye/TuriCreateDemo&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ref-2: App Coda 的範例, 分辨照片是湯或是飯&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.appcoda.com/core-ml-model-with-python/&quot; title=&quot;https://www.appcoda.com/core-ml-model-with-python/&quot;&gt;&lt;strong&gt;Creating a Custom Core ML Model Using Python and Turi Create&lt;/strong&gt;&lt;br /&gt;
_In the past few years, the use of machine learning approaches to solve problems and perform complex tasks have been…_www.appcoda.com&lt;/a&gt;&lt;a href=&quot;https://www.appcoda.com/core-ml-model-with-python/&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By &lt;a href=&quot;https://medium.com/@atimis19&quot;&gt;Marvin Lin&lt;/a&gt; on &lt;a href=&quot;https://medium.com/p/b3071ffde3af&quot;&gt;August 20, 2018&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/using-turi-create-build-an-image-classification-app-core-ml-b3071ffde3af&quot;&gt;Canonical link&lt;/a&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="Swift" /><category term="Core ML" /><category term="MLKit" /><category term="Swift" /><summary type="html">使用 Turi Create 製作圖案辨識的 App - Core ML and Vision * { font-family: Georgia, Cambria, “Times New Roman”, Times, serif; } html, body { margin: 0; padding: 0; } h1 { font-size: 50px; margin-bottom: 17px; color: #333; } h2 { font-size: 24px; line-height: 1.6; margin: 30px 0 0 0; margin-bottom: 18px; margin-top: 33px; color: #333; } h3 { font-size: 30px; margin: 10px 0 20px 0; color: #333; } header { width: 640px; margin: auto; } section { width: 640px; margin: auto; } section p { margin-bottom: 27px; font-size: 20px; line-height: 1.6; color: #333; } section img { max-width: 640px; } footer { padding: 0 20px; margin: 50px 0; text-align: center; font-size: 12px; } .aspectRatioPlaceholder { max-width: auto !important; max-height: auto !important; } .aspectRatioPlaceholder-fill { padding-bottom: 0 !important; } header, section[data-field=subtitle], section[data-field=description] { display: none; }</summary></entry></feed>