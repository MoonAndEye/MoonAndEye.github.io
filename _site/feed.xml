<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-14T15:05:48+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Marvin Lin’s Blogger</title><subtitle>這個 blog 是包含了的軟體開發、投資、經驗和生活故事。透過這個 blog，我希望分享自己的生活和見聞，同時也透過這個平台與讀者交流互動，建立起彼此的社群。</subtitle><entry><title type="html">SwiftUI &amp;amp; Compose</title><link href="http://localhost:4000/swift/2022/06/03/swiftui-and-compose.html" rel="alternate" type="text/html" title="SwiftUI &amp;amp; Compose" /><published>2022-06-03T22:33:38+08:00</published><updated>2022-06-03T22:33:38+08:00</updated><id>http://localhost:4000/swift/2022/06/03/swiftui-and-compose</id><content type="html" xml:base="http://localhost:4000/swift/2022/06/03/swiftui-and-compose.html">&lt;p&gt;Google 的現在正在推 Android study jam 活動，心裡因為好奇，所以也在線上參與了 Study jam 的說明活動。&lt;/p&gt;

&lt;p&gt;詳細的文章我寫在另一篇，可以直接從下方連結過去&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/android-study-jam-%E4%BB%8B%E7%B4%B9-fc2c44dd2f64&quot; title=&quot;https://medium.com/@atimis19/android-study-jam-%E4%BB%8B%E7%B4%B9-fc2c44dd2f64&quot;&gt;&lt;strong&gt;Android Study Jam — 介紹&lt;/strong&gt;&lt;br /&gt;
_Google 官方是很重視 Android 開發環境的，常常會推出不同區域的 Study Jam。這些練習會分成數個階段，當你完成每個階段，都可以拿到徽章，在 2022/06/23 內完成指定的題目後，還會有 Google…_medium.com&lt;/a&gt;&lt;a href=&quot;https://medium.com/@atimis19/android-study-jam-%E4%BB%8B%E7%B4%B9-fc2c44dd2f64&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;在說明會中，我看到 Android 也有一個以宣告式方法，來進行 UI rendering 的框架 — Compose。這個框架可以和 iOS 開發環境中的 SwiftUI 可以進行類比。&lt;/p&gt;

&lt;p&gt;在 Study Jam 說明會中，Tim Lin 示範了用 Compose 畫出一個 Text Label。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*2CZhpAOPfHN_baUdGtkIIA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tim Lin 在 Study jam 中的案例&lt;/p&gt;

&lt;p&gt;於是，我好奇的想，如果我在 SwiftUI 中，使用和 Compose 的排列方式一樣的時候，兩個平台畫出來的東西，會不會一樣呢? (如果會的話….事情就簡單多了)。所以下方就是一個和上面 Compose 一樣順序的 SwiftUI 程式碼。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*EZMuPTxtjvOyFYtkJMgXrg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和上方 Compose 一樣順序的 SwiftUI 程式碼&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*rfx2jRCOGrcDpGyuxpaceA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看渲染的 preview，就會知道，雙方的渲染邏輯不一樣。在 Compose 第一行的 background，會是整個元件的底色(紅色區域)，然後在下一個區域，加上圓角，保留 8 dp 的 padding 後，再畫出黃色區域。&lt;/p&gt;

&lt;p&gt;而 SwiftUI 元件下方第一行的 background，是這個 Text 的 background，然後加上 8 pt 的 padding，再畫上黃色 background。而最後的 4 pt padding，就會產生了 SwiftUI 的白色區域。因為我現在並沒有多的硬碟空間裝 Android Studio 了，所以我目前無法確定 Compose 最外層，或是 Compose 元件套疊的狀況。但 SwiftUI 最後一行的 4pt padding，是有他的意義的，而在沒有多餘顏色下，他會是 default background。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;目前對於 SwiftUI / Compose 都沒有很明確的結論，仍然在研究中。&lt;/p&gt;

&lt;p&gt;也歡迎大家回覆對於這兩個框架的想法。&lt;/p&gt;

&lt;p&gt;Exported from &lt;a href=&quot;https://medium.com&quot;&gt;Medium&lt;/a&gt; on March 14, 2023.&lt;/p&gt;</content><author><name></name></author><category term="Swift" /><summary type="html">Google 的現在正在推 Android study jam 活動，心裡因為好奇，所以也在線上參與了 Study jam 的說明活動。</summary></entry><entry><title type="html">Kotlin Multiplatform Mobile beta roadmap 重點節錄</title><link href="http://localhost:4000/kotlin/cross%20platform/2022/02/04/Kotlin-Multiplatform-mobile-roadmap.html" rel="alternate" type="text/html" title="Kotlin Multiplatform Mobile beta roadmap 重點節錄" /><published>2022-02-04T14:53:00+08:00</published><updated>2022-02-04T14:53:00+08:00</updated><id>http://localhost:4000/kotlin/cross%20platform/2022/02/04/Kotlin-Multiplatform-mobile-roadmap</id><content type="html" xml:base="http://localhost:4000/kotlin/cross%20platform/2022/02/04/Kotlin-Multiplatform-mobile-roadmap.html">&lt;h3 id=&quot;kotlin-multiplatform-mobile-beta-roadmap重點節錄&quot;&gt;Kotlin Multiplatform Mobile beta roadmap 重點節錄&lt;/h3&gt;

&lt;p&gt;在 2021 年 相關團隊發佈了 KMM beta 版本 roadmap 的影片。影片講者 Ekaterina Petrova 提到了數個 Alpha 到 Beta版本改進的內容，主要為&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新的記憶體管理機制&lt;/li&gt;
  &lt;li&gt;與 Apple 開法者想關的整合工具&lt;/li&gt;
  &lt;li&gt;Hierarchical Project 結構調整成預設&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;通常，你只需要針對不同平台的特性，去針對特定平台的 API 進行程式的撰寫。但當使用 KMM 進行共用程式碼開發時，有時候你仍然要對共用程式碼進行不同平台的特化。&lt;/p&gt;

&lt;p&gt;其中一個例子，就是在併發情境下，Alpha 版的 KMM 在記憶體管理上，容易造成問題，且學習曲線陡峭。開發團隊在 2021 年中的時候，就表示未來的 Kotlin (Beta 版) 會在這個方面進行優化。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Apple Integration&lt;/p&gt;

&lt;p&gt;KMM 在 Kotlin 專案的使用，「聽說」已經是相當友善了。而在 Apple 平台，用 embedAndSignAppleFrameworkForXcodeTest 取代以往手動的 packForXcodeTask，此外，還加強了 CocoaPods GradlePlugin DSL 的功能。但這邊有提到，這個 feature 應該會在 Beta release 後進行。&lt;/p&gt;

&lt;p&gt;剩下的 Apple project 整合功能，因為還沒開始測試，所以這邊先不介紹剩下的部分&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;KMM stable for migration&lt;/p&gt;

&lt;p&gt;會在 2022 春季進入 beta，講者說以後會兼顧兼容性，所以應該不用怕大的改動把你的 codebase 搞壞 （Swift 1.0 表示….）&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Kotlin Beta roadmap 的影片&lt;/p&gt;

&lt;p&gt;在 jetbrains 的文章&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2021/10/kmm-beta-roadmap-video-highlights/&quot; title=&quot;https://blog.jetbrains.com/kotlin/2021/10/kmm-beta-roadmap-video-highlights/&quot;&gt;&lt;strong&gt;KMM Beta Roadmap Video Highlights | The Kotlin Blog&lt;/strong&gt;&lt;br /&gt;
_The Kotlin 2021 Premier Online Event is in full swing, and The KMM Beta Roadmap video is already available for you to…_blog.jetbrains.com&lt;/a&gt;&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2021/10/kmm-beta-roadmap-video-highlights/&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By &lt;a href=&quot;https://medium.com/@atimis19&quot;&gt;Marvin Lin&lt;/a&gt; on &lt;a href=&quot;https://medium.com/p/60f673b3eda7&quot;&gt;February 4, 2022&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/kotllin-multiplatform-mobile-beta-roadmap-%E9%87%8D%E9%BB%9E%E7%AF%80%E9%8C%84-60f673b3eda7&quot;&gt;Canonical link&lt;/a&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="[&quot;Kotlin&quot;, &quot;Cross platform&quot;]" /><category term="KMM" /><category term="kotlin" /><category term="cross platform" /><summary type="html">Kotlin Multiplatform Mobile beta roadmap 重點節錄</summary></entry><entry><title type="html">資料密集型應用系統設計-第六章筆記</title><link href="http://localhost:4000/system%20design/2021/11/02/data-intensive-applications.html" rel="alternate" type="text/html" title="資料密集型應用系統設計-第六章筆記" /><published>2021-11-02T15:01:00+08:00</published><updated>2021-11-02T15:01:00+08:00</updated><id>http://localhost:4000/system%20design/2021/11/02/data-intensive-applications</id><content type="html" xml:base="http://localhost:4000/system%20design/2021/11/02/data-intensive-applications.html">&lt;p&gt;這世界上沒有銀色子彈 https://g.co/kgs/G7QbDr&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;資料密集型應用系統設計-第六章筆記&quot;&gt;資料密集型應用系統設計-第六章筆記&lt;/h3&gt;

&lt;p&gt;這世界上沒有銀色子彈 &lt;a href=&quot;https://g.co/kgs/G7QbDr&quot;&gt;https://g.co/kgs/G7QbDr&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*ifN_ysbEQV3aPal21VYuXQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;為什麼需要分區&quot;&gt;為什麼需要分區?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;可擴充性增加&lt;/li&gt;
  &lt;li&gt;只要業務量增加，最終單一伺服務總會遇到上限，在需要擴增的狀況下，選擇適當的分區策略，對未來的業務會有更大的助益。&lt;/li&gt;
  &lt;li&gt;增加效率&lt;/li&gt;
  &lt;li&gt;當分區策略做的好，在查找的效率會提高。&lt;/li&gt;
  &lt;li&gt;增加安全性&lt;/li&gt;
  &lt;li&gt;在特定狀況，可以將資料分成敏感性和非敏感性，分開存放。並在前面放上 security control，在不同&lt;/li&gt;
  &lt;li&gt;增加操作的彈性&lt;/li&gt;
  &lt;li&gt;因為不只一個儲存資料的地方，就可以有更多可優化的方法。像是 management, monitoring, backup and restore&lt;/li&gt;
  &lt;li&gt;讓資料的本質更貼近儲存的型別&lt;/li&gt;
  &lt;li&gt;分區是可以依照資料類型而分的。對於大的 binary data 的資料，放進對 blob storage 有優化的區，比放在 document database 更好。&lt;/li&gt;
  &lt;li&gt;增加可靠性&lt;/li&gt;
  &lt;li&gt;分區可以避免 single point of failure 等情形。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;分區的策略&quot;&gt;分區的策略&lt;/h3&gt;

&lt;h3 id=&quot;水平分區-horizontal-partitioning&quot;&gt;水平分區 Horizontal partitioning&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*aLGFA24i3vdS5Fioh3SCKg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每個分區分掉一部分的資料，這個策略中比較好的策略是讓每個分區對系統的負擔是差不多。每個分區擁有相同的 schema。每個分區也被稱之為 shard 。&lt;/p&gt;

&lt;p&gt;水平分區的舉例，會將分區依照 key 的字母順序排列。這個策略最重要的是決定 sharding key 的範圍，因為策略一但執行並上線之後，就很難再度調整。&lt;/p&gt;

&lt;p&gt;但這並不表示應該讓每個分區所擁有的「數量」一樣，在書本上的例子，是用百科全書為例。但是百科全書是個出版品，如果出版社想讓每本書的厚度相近，就會設計的讓頁數相近，所以排列的方法是讓字母順序的分區，能讓分區後的詞類和解釋的數量相近。&lt;/p&gt;

&lt;p&gt;但是就資料庫而言，並不單純是「擁有的資料」，也有可能依照現實情境設計。可以設計成某個 shards 擁有的資料很大，但每個 item 的讀/寫頻率很低。而其他分區擁有的資料很小，但是讀/寫頻率很高。&lt;/p&gt;

&lt;p&gt;要注意的點:&lt;/p&gt;

&lt;p&gt;要確保每一個 shard 不會超過機器的物理上限。&lt;/p&gt;

&lt;p&gt;需要避免製造出會影響效能或可靠近的「熱區」，舉例來說，如果設計讓顧客的首字字母當做分區的 Key 分類，就會造成某些分佈不均，因為人類的語言上會有常用習慣。可以替代的方案，就是先經過 hash 函數，再分散放入分區中。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;垂直分區-vertical-partitioning&quot;&gt;&lt;strong&gt;垂直分區 Vertical partitioning&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*XXjsPN9UtOCuhKUV9Bj7HA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每個分區都擁是原始資料的子集合。舉例來說，將欄位分成常用和不常用的部分，常用的欄位放在某一分區，不常用的放另一分區。&lt;/p&gt;

&lt;p&gt;縱向分區最常使用的場景，就是減少 I/O 和降低高頻率拉取資料的成本。&lt;/p&gt;

&lt;p&gt;以上 Fig2 為例，一個分區存放高頻率被存取的資料，包含產品名稱，描述，價格。另一個分區存放的資料，是倉庫中的庫存和上次訂購的時間。在這個例子中，這個系統常常會因為 App 需要顯示，而要去 query 產品名稱、描述、價格。&lt;/p&gt;

&lt;p&gt;而庫存數量和上次購買日期會放在一區，是因為這兩個 item 常常一起在同一個區段顯示。&lt;/p&gt;

&lt;p&gt;其他優點&lt;/p&gt;

&lt;p&gt;不常變更的項目，和常常變更的項目會切開。在這個例子中，產品名稱，描述，價格是不常變動項目。而庫存數目和上次購買日期是常常變動的項目。而不常變動項目的區間，是很容易被選到放在記憶體中的快取。&lt;/p&gt;

&lt;p&gt;敏感型資料可以分區存放，並加上 additional security controls。&lt;/p&gt;

&lt;p&gt;垂直分區可以減少所需的併發型 access。以上面的例子來說，如果當 client 真的發生訂購行為，會更動庫存和上次購買時間。垂直分區的策略，不會讓整條 row 鎖住。而這個策略，也因為只要特定欄位，在 MSSql 以 Page 為單位時，每個 Page 可包含的 row 數量會比使用水平分區策略的多。&lt;/p&gt;

&lt;p&gt;功能分區 Functional partitioning (Microsoft 的文章)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*MUsz-zJi4R9v_hZRYzaacw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;功能分區。將資料依照「如何被使用」來分，舉例來說，如果架設電商系統的分區，會將產品庫存資料放在一個分區，而發票/收據資料，放在另一個分區。&lt;/p&gt;

&lt;p&gt;如果商業邏輯的邊界是很明顯的，那依照功能切分是可以提升效率的。常用的場景是，將 read-write data 和 read-only data 放在不同區分。在 Fig 3 中的場景，是將庫存資料和客戶資料放在不同區分。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;key-or-hashed-basesharding&quot;&gt;Key or hashed base sharding&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*Fac4H-wdk02et48Lm9thiw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假設你有四台 database servers，每個 request 都有 application id。只要使用 hash 和 mod ，就能將資料分散到四台機器上。&lt;/p&gt;

&lt;p&gt;這個方法的主要缺點是， elastic load balancing (dynamically adding/removing database servers) 會非常困難，而且成本很高。&lt;/p&gt;

&lt;p&gt;假設，你想要多加六台機器，就必需進行 remapp 和 migration。除此之外，你還要調整你的 hash function，從 mod 4 變成 mod 10。&lt;/p&gt;

&lt;p&gt;現在，是有不停機的轉換的方式，如 Consistant Hashing，參考資料如下。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acodersjourney.com/system-design-interview-consistent-hashing/&quot;&gt;https://www.acodersjourney.com/system-design-interview-consistent-hashing/&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;directory-basedsharding&quot;&gt;Directory based sharding&lt;/h3&gt;

&lt;p&gt;Directory based shard 分區會在分區前面加上 lookup service。lookup service 知道現在的分區 scheme，並在系統中留存一份 map 紀錄。&lt;/p&gt;

&lt;p&gt;client 端會先去問 lookup service，去找出 entity 是被放在哪個 shard，然後才會進行查找的動作。&lt;/p&gt;

&lt;p&gt;優點&lt;/p&gt;

&lt;p&gt;可以解決 elastic scaling 問題，而且是在不使用 consistent hashing 的前提。先假設前面的擴張情況，四個 database service 配上 hashed based 區分策略。現在要加上六個 database servers 而且不想停機。&lt;/p&gt;

&lt;p&gt;步驟如下&lt;/p&gt;

&lt;p&gt;1&amp;gt; lookup service 仍然使用 mod 4 hash function&lt;/p&gt;

&lt;p&gt;2&amp;gt; 先區分出，如果在 mod 10 的狀況下，資料該怎麼區分&lt;/p&gt;

&lt;p&gt;3&amp;gt; 寫一段 script 把所有的資料 copy 到新的六台 shards 上，注意，此時並不會刪掉原來四台上的資料。&lt;/p&gt;

&lt;p&gt;4&amp;gt; 當 copy 完成，換掉 lookup service 上的 hash function，從 mod 4 換成 mod 10。&lt;/p&gt;

&lt;p&gt;5&amp;gt; 將 4 台舊資料上的資料清掉 (稱之為 purge 或 clean up)。&lt;/p&gt;

&lt;p&gt;在實務上要注意的地方&lt;/p&gt;

&lt;p&gt;migration 時，使用者還是有可能在更新資料。可能的解法，將系統轉為 read-only mode。或是先將這個時間的資料，放到另一個 service 上，等到 migration 結束再移回來。&lt;/p&gt;

&lt;p&gt;copy 和 clean up 對效能會有很大影響。可能解法就是 cloning and elastic load balancing，但這兩個方法的成本都很高&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;參考文章&quot;&gt;參考文章&lt;/h3&gt;

&lt;p&gt;分區的文章&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acodersjourney.com/database-sharding/&quot;&gt;https://www.acodersjourney.com/database-sharding/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Consistent Hashing&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acodersjourney.com/system-design-interview-consistent-hashing/&quot;&gt;https://www.acodersjourney.com/system-design-interview-consistent-hashing/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Microsoft 對工作負載和熱點降溫&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/best-practices/data-partitioning&quot;&gt;https://docs.microsoft.com/en-us/azure/architecture/best-practices/data-partitioning&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By &lt;a href=&quot;https://medium.com/@atimis19&quot;&gt;Marvin Lin&lt;/a&gt; on &lt;a href=&quot;https://medium.com/p/c8b1ddc94554&quot;&gt;November 2, 2021&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@atimis19/designing-data-intensive-applications-notes-c8b1ddc94554&quot;&gt;Canonical link&lt;/a&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="system design" /><category term="system design" /><summary type="html">這世界上沒有銀色子彈 https://g.co/kgs/G7QbDr</summary></entry></feed>