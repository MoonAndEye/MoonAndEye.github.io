<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-20T13:54:41+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Marvin Lin’s Blogger</title><subtitle>這個 blog 是包含了的軟體開發、投資、經驗和生活故事。透過這個 blog，我希望分享自己的生活和見聞，同時也透過這個平台與讀者交流互動，建立起彼此的社群。</subtitle><author><name>Marvin Lin</name></author><entry><title type="html">使用 ChatGPT 串接 ChatGPT：(2)</title><link href="http://localhost:4000/chatgpt/using-chatgpt-connect-chatgpt2.html" rel="alternate" type="text/html" title="使用 ChatGPT 串接 ChatGPT：(2)" /><published>2023-03-20T13:03:00+08:00</published><updated>2023-03-20T13:03:00+08:00</updated><id>http://localhost:4000/chatgpt/using-chatgpt-connect-chatgpt2</id><content type="html" xml:base="http://localhost:4000/chatgpt/using-chatgpt-connect-chatgpt2.html">&lt;h2 id=&quot;前情提要&quot;&gt;前情提要&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;/chatgpt/using-chatgpt-connect-chatgpt1.html&quot;&gt;使用 ChatGPT 串接 ChatGPT：(1)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&quot;/chatgpt/using-chatgpt-connect-chatgpt1.html&quot;&gt;前一篇文章&lt;/a&gt;中，我們使用了 python 語言串接了 ChatGPT API。但我現在是個 iOS 開發者，所以會想要試試看能不能直接用 ChatGPT，省時省力(？)的幫我完成一個串接 ChatGPT 的 App。&lt;/p&gt;

&lt;h2 id=&quot;開始用-chatgpt-產生-ios-app-程式碼&quot;&gt;開始用 ChatGPT 產生 iOS App 程式碼&lt;/h2&gt;

&lt;h2 id=&quot;先從-api-request-開始&quot;&gt;先從 api request 開始&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;問：
我已經有 ChatGPT 的 api key 了，請問怎麼用 Swift 串接 ChatGPT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
要使用 Swift 串接 ChatGPT，您可以使用以下步驟：

請確保您已經安裝了 Alamofire 套件，該套件可以讓您在 Swift 中輕鬆進行 HTTP 請求。

準備一個 HTTP POST 請求，並傳遞以下參數：

網址：https://api.openai.com/v1/engines/davinci-codex/completions
標題：Authorization
值：Bearer YOUR_API_KEY
標題：Content-Type
值：application/json
請求正文：{&quot;prompt&quot;: &quot;YOUR_PROMPT&quot;}
在這裡，YOUR_API_KEY 是您的 ChatGPT API 金鑰，YOUR_PROMPT 是您想要傳遞給 ChatGPT 的提示。

使用 Alamofire 套件發送 HTTP POST 請求，並處理返回的 JSON 格式回應：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import Alamofire

let apiURL = &quot;https://api.openai.com/v1/engines/davinci-codex/completions&quot;
let headers: HTTPHeaders = [
    &quot;Authorization&quot;: &quot;Bearer YOUR_API_KEY&quot;,
    &quot;Content-Type&quot;: &quot;application/json&quot;
]
let parameters: Parameters = [
    &quot;prompt&quot;: &quot;YOUR_PROMPT&quot;
]

AF.request(apiURL, method: .post, parameters: parameters, encoding: JSONEncoding.default, headers: headers).responseJSON { response in
    switch response.result {
    case .success(let value):
        // 處理返回的 JSON 格式回應
        if let json = value as? [String: Any],
            let choices = json[&quot;choices&quot;] as? [[String: Any]],
            let text = choices.first?[&quot;text&quot;] as? String {
            // 在這裡處理您收到的文本回應
            print(text)
        }
    case .failure(let error):
        // 在這裡處理 HTTP 請求失敗的錯誤
        print(error)
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;這樣您就可以使用 Swift 串接 ChatGPT 了。請注意，這只是一個簡單的範例，您可能需要根據您的具體需求進行更多調整和擴展。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;接下來加上一個簡單的畫面包含-prompt-輸入api-request-buttonresponse-呈現&quot;&gt;接下來加上一個簡單的畫面，包含 prompt 輸入，api request button，response 呈現&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;問：
幫我生成一個 iOS App 畫面，來串接 ChatGPT，畫面上要有個文字輸入框，這個輸入框的內容就是 ChatGPT API 的 prompt，下方有一個 button，按下去後會發送 api request。再下方要能顯示 ChatGPT回應的 response text。請使用 SwiftUI 來寫這個頁面
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：

import SwiftUI
import Alamofire

struct ContentView: View {
    @State var promptText: String = &quot;&quot;
    @State var responseText: String = &quot;&quot;
    let apiURL = &quot;https://api.openai.com/v1/engines/davinci-codex/completions&quot;
    let headers: HTTPHeaders = [
        &quot;Authorization&quot;: &quot;Bearer YOUR_API_KEY&quot;,
        &quot;Content-Type&quot;: &quot;application/json&quot;
    ]
    
    var body: some View {
        VStack {
            TextField(&quot;Enter prompt here&quot;, text: $promptText)
                .padding()
                .border(Color.gray)
            
            Button(action: {
                sendRequest()
            }) {
                Text(&quot;Send Request&quot;)
            }
            .padding()
            
            Text(responseText)
                .padding()
        }
    }
    
    func sendRequest() {
        let parameters: Parameters = [
            &quot;prompt&quot;: promptText
        ]
        
        AF.request(apiURL, method: .post, parameters: parameters, encoding: JSONEncoding.default, headers: headers).responseJSON { response in
            switch response.result {
            case .success(let value):
                if let json = value as? [String: Any],
                    let choices = json[&quot;choices&quot;] as? [[String: Any]],
                    let text = choices.first?[&quot;text&quot;] as? String {
                    DispatchQueue.main.async {
                        responseText = text
                    }
                }
            case .failure(let error):
                print(error)
            }
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在這個程式碼中，我們使用了 @State 屬性來管理 promptText 和 responseText 的狀態。當使用者輸入提示文本後，我們可以從 promptText 中取得輸入的值。當使用者按下“Send Request”按鈕時，我們會使用 Alamofire 發送一個 HTTP POST 請求，並處理返回的 JSON 格式回應，將回應文本更新到 responseText 中。最後，我們在畫面上顯示了這個回應文本。

請注意，此程式碼僅為示範，實際使用中可能需要添加更多的錯誤處理和用戶體驗。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;驗證-ai-寫出來的專案會不會動&quot;&gt;驗證 AI 寫出來的專案會不會動&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/swift/chatgpt/chatgpt-connect-ios-app.jpeg&quot; alt=&quot;ChatGPT 生出來的畫面&quot; width=&quot;250px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;畫面上看起來不錯，那我們就來試試看會不會動吧。我試著輸入”tell me a joke”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/swift/chatgpt/chatgpt-connect-codex-result.jpeg&quot; alt=&quot;原始 ChatGPT 的結果&quot; width=&quot;250px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;他出現了很奇怪的結果，所以我把原始 response print 出來看看&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;success({
    choices =     (
                {
            &quot;finish_reason&quot; = length;
            index = 0;
            logprobs = &quot;&amp;lt;null&amp;gt;&quot;;
            text = &quot;:\&quot;))\n            self.nw.append(utils.normalizeString&quot;;
        }
    );
    created = 1679291111;
    id = &quot;cmpl-6w2cRytpMNtkDeuiuH15Pl8qky62C&quot;;
    model = &quot;davinci-codex&quot;;
    object = &quot;text_completion&quot;;
    usage =     {
        &quot;completion_tokens&quot; = 16;
        &quot;prompt_tokens&quot; = 3;
        &quot;total_tokens&quot; = 19;
    };
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;這時候，就需要開發者介入了，在他的 model 中，使用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;davinci-codex&lt;/code&gt; model，這並不是網頁版那個大家覺得好用的 model，所以我們對 endpoint 進行置換。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// 置換前
    let apiURL = &quot;https://api.openai.com/v1/engines/davinci-codex/completions&quot;

/// 置換後
    let apiURL = &quot;https://api.openai.com/v1/engines/text-davinci-003/completions&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/swift/chatgpt/chatgpt-connect-davinci-result.jpeg&quot; alt=&quot;davinci 的結果&quot; width=&quot;250px&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;success({
    choices =     (
                {
            &quot;finish_reason&quot; = stop;
            index = 0;
            logprobs = &quot;&amp;lt;null&amp;gt;&quot;;
            text = &quot; feeling?\n\nI&apos;m feeling great thank you.&quot;;
        }
    );
    created = 1679290920;
    id = &quot;cmpl-6w2ZMgsKECySpi2OFONc9HX31FJm6&quot;;
    model = &quot;text-davinci-003&quot;;
    object = &quot;text_completion&quot;;
    usage =     {
        &quot;completion_tokens&quot; = 11;
        &quot;prompt_tokens&quot; = 3;
        &quot;total_tokens&quot; = 14;
    };
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;結論---這個階段人類開發者還是需要去看-chatgpt-的程式碼並進行-debug&quot;&gt;結論 - 這個階段，人類開發者還是需要去看 ChatGPT 的程式碼，並進行 debug&lt;/h2&gt;

&lt;p&gt;從上面的例子可以得到幾個結論&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;程式碼會動&lt;/li&gt;
  &lt;li&gt;UI 看起來符合最低 demo 的標準&lt;/li&gt;
  &lt;li&gt;但如果 prmopt 不夠精確，要經過調整才能得得人類預期的結果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第三點這邊，我並不認為是單純是現在的 ChatGPT 的問題，畢竟，人類在溝通上，是省略了很多「已知」，或是直接假設對方「已知」的前提下，進行交談。或許在接下來的時間，人類會開始學著和 ChatGPT 進行溝通，改變人類自己的交談習慣，讓 ChatGPT 可以更快的了解人類要的結果。&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="swift" /><category term="Swift" /><category term="Programming" /><category term="AI" /><category term="ChatGPT" /><summary type="html">前情提要</summary></entry><entry><title type="html">台灣證交所網頁改版，RWD 網站設計</title><link href="http://localhost:4000/finance/2023/03/20/twse-website-rwd.html" rel="alternate" type="text/html" title="台灣證交所網頁改版，RWD 網站設計" /><published>2023-03-20T11:54:00+08:00</published><updated>2023-03-20T11:54:00+08:00</updated><id>http://localhost:4000/finance/2023/03/20/twse-website-rwd</id><content type="html" xml:base="http://localhost:4000/finance/2023/03/20/twse-website-rwd.html">&lt;h2 id=&quot;證交所公告&quot;&gt;證交所公告&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.twse.com.tw/zh/about/news/news/content.html?ff80808186cea0de0186fce2babc0066&quot;&gt;證交所公告 link&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;證交所新聞稿&quot;&gt;證交所新聞稿&lt;/h2&gt;

&lt;p&gt;臺灣證券交易所股份有限公司 新聞稿
中華民國112年3月20日
資訊服務部
臺灣證券交易所官網全面改版為響應式(RWD)網站設計，於3月19日推
出
臺灣證券交易所官網為提升行動裝置使用者之操作體驗，強化網站友善度及互
動性，於今(2023)年3月19日將本公司官網全面改版為響應式(RWD)網站設計，取代
與電腦版不同頁面、網址，且屬老舊技術的行動版網站。依據流量分析統計，越來
越多人透過行動裝置來瀏覽本公司網頁，比例已超過50%。各類行動裝置的螢幕大
小、比例、操作習慣與使用電腦有所不同，如用手機看電腦規格的網頁，常需操作
放大縮小，以觀看內容。
本次改版採用響應式網頁設計(Responsive Web Design)，同一個網址上看到的內
容，在不同螢幕寬度(桌機、平版、手機)會自動適應產生不同的版面變化，圖像尺寸
和字體將更加利於行動裝置上瀏覽，所設計的網站連接和按鈕將更容易觸發點擊，
有著形象視覺一致、減少維護成本、集中網站流量、加高搜尋引擎結果排名與易於
使用者分享網站等優點。
以使用行動裝置瀏覽本公司官網報表為例：改版後，遇到較寬的報表時，會將
重要欄位(如證券代號、日期等)固定住，使用者透過手指左右拖拉即可依序看到表
格後面欄位的內容，同時亦可清楚知道目前瀏覽項目的證券代號或日期，充分落實
以使用者為中心的設計。
臺灣證券交易所透過優化網站使用者操作體驗(User Experience)，提升使用者網
站操作便利性、友善度及互動性，為持續吸引及服務國內外投資人投資臺灣資本市
場而努力。&lt;/p&gt;

&lt;h2 id=&quot;rwd-參考資料&quot;&gt;RWD 參考資料&lt;/h2&gt;

&lt;p&gt;RWD（Responsive Web Design）指的是設計能夠自動調整網站版面以適應不同的裝置大小和屏幕解析度的技術。現在越來越多的使用者通過移動設備上網，因此，RWD設計變得越來越重要。&lt;/p&gt;

&lt;p&gt;首先，RWD設計可以提供更好的使用者體驗。如果一個網站不能自動適應裝置大小，使用者就必須不斷地放大和縮小網頁，以找到他們需要的內容，這樣的體驗是非常糟糕的。相反，RWD設計可以讓網站適應不同的屏幕大小和裝置，使使用者能夠更輕鬆地尋找他們所需要的信息，提供更好的瀏覽體驗。&lt;/p&gt;

&lt;p&gt;其次，RWD設計可以提高網站的可用性。如果一個網站不能正確地顯示在移動設備上，那麼它就會失去一部分的受眾。這意味著使用者可能會因為網站不符合他們的期望而放棄訪問。而使用RWD設計可以確保網站可以適應不同的裝置和屏幕大小，讓更多的使用者能夠輕鬆訪問網站。&lt;/p&gt;

&lt;p&gt;最後，RWD設計還可以提高網站的SEO排名。由於Google等搜索引擎優先顯示適應不同設備的網站，因此使用RWD設計可以讓您的網站更容易在搜索引擎中被發現，並且在搜索排名上取得更好的成績。&lt;/p&gt;

&lt;p&gt;綜上所述，RWD設計是現代網站設計的重要組成部分，它可以提高網站的使用者體驗、可用性和SEO排名。如果您正在考慮重新設計您的網站，請務必考慮使用RWD設計，以提供最佳的網站體驗。&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="finance" /><category term="finance" /><category term="證交所" /><category term="RWD" /><summary type="html">證交所公告</summary></entry><entry><title type="html">小吃推薦：楊家紅豆餅-新北板橋江子翠</title><link href="http://localhost:4000/life/2023/03/20/yang-red-been.html" rel="alternate" type="text/html" title="小吃推薦：楊家紅豆餅-新北板橋江子翠" /><published>2023-03-20T09:16:00+08:00</published><updated>2023-03-20T09:16:00+08:00</updated><id>http://localhost:4000/life/2023/03/20/yang-red-been</id><content type="html" xml:base="http://localhost:4000/life/2023/03/20/yang-red-been.html">&lt;p&gt;&lt;img src=&quot;/assets/life/food/yang_red_been.jpeg&quot; alt=&quot;楊家紅豆餅&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;楊家紅豆餅&quot;&gt;楊家紅豆餅&lt;/h2&gt;

&lt;h2 id=&quot;營業時間早上11點開始賣完為止&quot;&gt;營業時間：早上11點開始，賣完為止&lt;/h2&gt;

&lt;p&gt;這家紅豆餅店位於江子翠地區，已經經營十年以上。這家店的特色是他們只賣兩種口味的餅點：紅豆餅和奶油餅。但是這兩種口味都被做到了極致，令人回味無窮。&lt;/p&gt;

&lt;p&gt;紅豆餅的內餡香甜，且每一口都有紅豆的口感，而餅皮則是脆而不硬，口感非常好。奶油餅則是濃郁的奶油香氣和鬆軟的餅體融合在一起，給人一種非常獨特的口感。雖然店家只賣這兩種口味，但是每一種口味都非常優秀，是一種無法用言語形容的美味。&lt;/p&gt;

&lt;p&gt;此外，這家店的餅點使用的是優質的食材，每天限量販售也保證了餅點的新鮮度，因此如果您想嚐試這家店的餅點，建議您早一點來，以免向隅。&lt;/p&gt;

&lt;p&gt;總之，如果您對紅豆餅和奶油餅感興趣，不妨到這家店品嚐一下。我相信您一定不會失望。&lt;/p&gt;

&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3615.2511399399245!2d121.46905985062942!3d25.025549883897703!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x3442a83fa20267a7%3A0xa8542f3b1b1b8b!2z5qWK5a6257SF6LGG6aSF!5e0!3m2!1szh-TW!2stw!4v1679275706894!5m2!1szh-TW!2stw&quot; width=&quot;600&quot; height=&quot;450&quot; style=&quot;border:0;&quot; allowfullscreen=&quot;&quot; loading=&quot;lazy&quot; referrerpolicy=&quot;no-referrer-when-downgrade&quot;&gt;&lt;/iframe&gt;</content><author><name>Marvin Lin</name></author><category term="life" /><category term="food" /><category term="美食" /><summary type="html"></summary></entry><entry><title type="html">使用 ChatGPT 串接 ChatGPT：(1)</title><link href="http://localhost:4000/chatgpt/using-chatgpt-connect-chatgpt1.html" rel="alternate" type="text/html" title="使用 ChatGPT 串接 ChatGPT：(1)" /><published>2023-03-19T12:36:00+08:00</published><updated>2023-03-19T12:36:00+08:00</updated><id>http://localhost:4000/chatgpt/using-chatgpt-connect-chatgpt1</id><content type="html" xml:base="http://localhost:4000/chatgpt/using-chatgpt-connect-chatgpt1.html">&lt;h2 id=&quot;申請-chatgpt-api-key&quot;&gt;申請 ChatGPT api key&lt;/h2&gt;

&lt;p&gt;ChatGPT 是有開放 API 讓使用者串接的，申請是免費的，但免費額度的用量是 18 USD，或是三個月到期，之後就需要升級成 plus 才能繼續使用。詳細情況，建議關注 open.ai 的網站，因為上面的資訊才是最新且最正確的。&lt;/p&gt;

&lt;h3 id=&quot;openai-價格說明網頁&quot;&gt;&lt;a href=&quot;https://openai.com/pricing&quot;&gt;Open.ai 價格說明網頁&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;那麼，我們就開始串接 ChatGPT 了，要進行 client 的串接，我們需要 api key。&lt;/p&gt;

&lt;h3 id=&quot;申請-api-key的網頁&quot;&gt;&lt;a href=&quot;https://platform.openai.com/account/api-keys&quot;&gt;申請 api key的網頁&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;你可以在這個網頁申請 api key，記得，拿到 key 後要馬上找到地方存起來，不然就再也看不到 keys 了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;這個網頁也有提醒，api key 不要放在 client 端，也不要放在公開的 repo 上&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接下來，我們就不斷的去問 ChatGPT，怎麼串接 ChatGPT。&lt;/p&gt;

&lt;h2 id=&quot;使用-chatgpt-來串接-chatgpt&quot;&gt;使用 ChatGPT 來串接 ChatGPT&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;問：
怎麼串接 ChatGPT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
要使用 ChatGPT API，您需要遵循以下步驟：

1 註冊 ChatGPT API 帳戶。前往 ChatGPT API 官方網站，點擊「註冊」按鈕，並填寫必要的註冊信息。

2 創建 API 金鑰。登錄到您的 ChatGPT API 帳戶後，創建一個新的 API 金鑰。API 金鑰是連接到 ChatGPT API 的唯一憑證，您需要使用它才能訪問 API 服務。

3 選擇適合的 API。ChatGPT API 提供了多個 API 功能，例如文字生成、對話系統、語言翻譯等。選擇適合您需求的 API。

4 創建 API 請求。使用您的 API 金鑰和適合的 API 端點創建 API 請求。API 端點是 API 服務的網址，您可以在 API 文檔中找到相關信息。在 API 請求中，您可以傳遞相應的參數和數據以訪問 API 服務。

5 處理 API 響應。一旦發送 API 請求，您會收到一個響應，其中包含 API 服務返回的結果。您可以根據響應中的數據進行下一步處理。

以上是使用 ChatGPT API 的一般步驟。您可以參考 ChatGPT API 官方文檔，以了解更多關於 API 的詳細信息，並且可以通過使用相關的庫和SDKs，使API集成更加容易。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;問：
給我一個串接 chat gpt 的範例
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
好的，以下是一個使用 Python 語言，並且使用 ChatGPT API 文本生成功能的簡單範例：

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
import openai
import os

# 設置 API 金鑰
openai.api_key = os.getenv(&quot;OPENAI_API_KEY&quot;)

# 準備 API 請求
prompt = &quot;Once upon a time,&quot;
model_engine = &quot;text-davinci-002&quot;
temperature = 0.5
max_tokens = 50

# 訪問 API 服務
response = openai.Completion.create(
    engine=model_engine,
    prompt=prompt,
    max_tokens=max_tokens,
    temperature=temperature,
)

# 處理 API 響應
generated_text = response.choices[0].text.strip()

# 輸出結果
print(generated_text)
這個範例會生成一段文本，該文本是在「Once upon a time,」這個開頭之後，使用 ChatGPT API 文本生成功能生成的。在這個例子中，我們使用了 openai Python 包，並且將 API 金鑰設置為環境變量。我們使用 openai.Completion.create 方法向 API 服務提交了一個文本生成的請求，並且通過處理 API 響應來獲得了生成的文本結果。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;直接拿-code-去跑的結果&quot;&gt;直接拿 code 去跑的結果&lt;/h2&gt;

&lt;p&gt;把 ChatGPT 給你的 Code 直接拿去跑，並照著指示換掉 api key，到底會不會動呢? 我們來看一下。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 結果

Traceback (most recent call last):
  File &quot;/Users/cm0679/5python/foo.py&quot;, line 14, in &amp;lt;module&amp;gt;
    response = openai.Completion.create(
  File &quot;/Users/cm0679/anaconda3/lib/python3.8/site-packages/openai/api_resources/completion.py&quot;, line 25, in create
    return super().create(*args, **kwargs)
  File &quot;/Users/cm0679/anaconda3/lib/python3.8/site-packages/openai/api_resources/abstract/engine_api_resource.py&quot;, line 149, in create
    ) = cls.__prepare_create_request(
  File &quot;/Users/cm0679/anaconda3/lib/python3.8/site-packages/openai/api_resources/abstract/engine_api_resource.py&quot;, line 106, in __prepare_create_request
    requestor = api_requestor.APIRequestor(
  File &quot;/Users/cm0679/anaconda3/lib/python3.8/site-packages/openai/api_requestor.py&quot;, line 130, in __init__
    self.api_key = key or util.default_api_key()
  File &quot;/Users/cm0679/anaconda3/lib/python3.8/site-packages/openai/util.py&quot;, line 186, in default_api_key
    raise openai.error.AuthenticationError(
openai.error.AuthenticationError: No API key provided. You can set your API key in code using &apos;openai.api_key = &amp;lt;API-KEY&amp;gt;&apos;, or you can set the environment variable OPENAI_API_KEY=&amp;lt;API-KEY&amp;gt;). If your API key is stored in a file, you can point the openai module at it with &apos;openai.api_key_path = &amp;lt;PATH&amp;gt;&apos;. You can generate API keys in the OpenAI web interface. See https://onboard.openai.com for details, or email support@openai.com if you have any questions.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我們得到了 AuthenticationError，從結果來看，一定是 api key 的設定有問題。但現在先不人工介入，我們先試試看 ChatGPT 能不能從這個結果給我一個改正後的 code。&lt;/p&gt;

&lt;h2 id=&quot;拿-error-的結果去問-chatgpt&quot;&gt;拿 Error 的結果去問 ChatGPT&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 問：
error message 如下
Traceback (most recent call last):
  File &quot;/Users/cm0679/5python/foo.py&quot;, line 14, in &amp;lt;module&amp;gt;
    response = openai.Completion.create(
  File &quot;/Users/cm0679/anaconda3/lib/python3.8/site-packages/openai/api_resources/completion.py&quot;, line 25, in create
    return super().create(*args, **kwargs)
  File &quot;/Users/cm0679/anaconda3/lib/python3.8/site-packages/openai/api_resources/abstract/engine_api_resource.py&quot;, line 149, in create
    ) = cls.__prepare_create_request(
  File &quot;/Users/cm0679/anaconda3/lib/python3.8/site-packages/openai/api_resources/abstract/engine_api_resource.py&quot;, line 106, in __prepare_create_request
    requestor = api_requestor.APIRequestor(
  File &quot;/Users/cm0679/anaconda3/lib/python3.8/site-packages/openai/api_requestor.py&quot;, line 130, in __init__
    self.api_key = key or util.default_api_key()
  File &quot;/Users/cm0679/anaconda3/lib/python3.8/site-packages/openai/util.py&quot;, line 186, in default_api_key
    raise openai.error.AuthenticationError(
openai.error.AuthenticationError: No API key provided. You can set your API key in code using &apos;openai.api_key = &amp;lt;API-KEY&amp;gt;&apos;, or you can set the environment variable OPENAI_API_KEY=&amp;lt;API-KEY&amp;gt;). If your API key is stored in a file, you can point the openai module at it with &apos;openai.api_key_path = &amp;lt;PATH&amp;gt;&apos;. You can generate API keys in the OpenAI web interface. See https://onboard.openai.com for details, or email support@openai.com if you have any questions.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 答：
這個錯誤信息顯示了在代碼中並沒有提供 ChatGPT API 金鑰。你需要設置你的 API 金鑰才能使用 ChatGPT API。你可以按照下列步驟操作：

訪問 OpenAI 控制台 (https://beta.openai.com/docs/quickstart)
創建一個帳戶 (如果你還沒有帳戶)
創建一個新的 API 金鑰 (https://beta.openai.com/docs/api-reference/authentication/create-api-key)
複製你的新 API 金鑰
在你的代碼中設置 openai.api_key 為你的 API 金鑰。
以下是代碼示例：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
python
Copy code
import openai

# 設置你的 API 金鑰
openai.api_key = &quot;YOUR_API_KEY_HERE&quot;

# 調用 ChatGPT API 文本生成功能
prompt = &quot;Once upon a time,&quot;
model_engine = &quot;text-davinci-002&quot;
temperature = 0.5
max_tokens = 50

response = openai.Completion.create(
    engine=model_engine,
    prompt=prompt,
    max_tokens=max_tokens,
    temperature=temperature,
)

# 處理 API 響應
generated_text = response.choices[0].text.strip()

# 輸出結果
print(generated_text)
請務必將 YOUR_API_KEY_HERE 替換為你自己的 ChatGPT API 金鑰。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;這次，ChatGPT 換掉了設定 api key 的那一段&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 更換前
openai.api_key = os.getenv(&quot;OPENAI_API_KEY&quot;)

# 更換後
openai.api_key = &quot;YOUR_API_KEY_HERE&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然後，再跑一次，我們得到了&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# response：
here was a little girl who loved to read. She would spend hours upon hours reading books of all kinds. She loved the smell of old books and the way they made her feel.

One day, she came across a book that she had
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;得到了一個故事的結果，因為我們的 prmopt 為 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Once upon a time,&lt;/code&gt; 所以 ChatGPT 就把他接成一個故事了。&lt;/p&gt;

&lt;h2 id=&quot;chatgpt-api-的那些參數&quot;&gt;ChatGPT API 的那些參數&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prompt = &quot;Once upon a time,&quot;
model_engine = &quot;text-davinci-002&quot;
temperature = 0.5
max_tokens = 50
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;prompt&quot;&gt;prompt&lt;/h3&gt;
&lt;p&gt;詠唱詞，ChatGPT 會依這個輸入，來回傳 response&lt;/p&gt;

&lt;h3 id=&quot;model_engin&quot;&gt;model_engin&lt;/h3&gt;
&lt;p&gt;使用的 ai model，模型的種類不同，建議從官網去找你想完成任務的模型。
注意，雖然 ChatGPT 給的是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text-davinci-002&lt;/code&gt; 但後面還有個 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text-davinci-003&lt;/code&gt;，然後2023年3月之後，還出了個 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gpt-3.5-turbo&lt;/code&gt;。每個模型的用途不同，能力也不同，請依使用場景去調整。&lt;/p&gt;

&lt;h3 id=&quot;temperature&quot;&gt;temperature&lt;/h3&gt;
&lt;p&gt;表示同樣的 prompt，給出一樣的 response 的機率，如果設定為 0，那一樣的 input 就會得到一樣的 response。調高一點，讓結果會不同。&lt;/p&gt;

&lt;h3 id=&quot;max_tokens&quot;&gt;max_tokens&lt;/h3&gt;
&lt;p&gt;token 可以想成是 response 的字數限制，每個模型的 max_token 都是不同的，所以調到 500，1000 都是可以的。注意，這和使用量有關，token 是算費用的。價格在下方的參考資料有列出來&lt;/p&gt;

&lt;h2 id=&quot;參考資料&quot;&gt;參考資料&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://openai.com/pricing&quot;&gt;open.ai pricing&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://platform.openai.com/docs/models&quot;&gt;API 可以選擇的 model 列表和 model 說明&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="swift" /><category term="swift" /><category term="programming" /><category term="ai" /><category term="chatgpt" /><category term="python" /><summary type="html">申請 ChatGPT api key</summary></entry><entry><title type="html">Swift 程式碼標準化工具 - swiftlint &amp;amp; swiftformat</title><link href="http://localhost:4000/swift/2023/03/18/swift-standard-tool.html" rel="alternate" type="text/html" title="Swift 程式碼標準化工具 - swiftlint &amp;amp; swiftformat" /><published>2023-03-18T14:26:00+08:00</published><updated>2023-03-18T14:26:00+08:00</updated><id>http://localhost:4000/swift/2023/03/18/swift-standard-tool</id><content type="html" xml:base="http://localhost:4000/swift/2023/03/18/swift-standard-tool.html">&lt;h1 id=&quot;swift-程式碼的標準化&quot;&gt;Swift 程式碼的標準化&lt;/h1&gt;

&lt;p&gt;在多人共同協作的專案中，Swift 程式碼的標準化是一個重要的主題，如果你的專案只有一個人，那標準化只需要那一位開發者，但我在實務上是會有三、四個人同時在一個專案的，想憑著過去的經驗讓這群人有程式碼風格的共識，是不可能的。。使用 Swiftlint 和 Swiftformat 可以幫助所有成員檢視和自動修正程式碼風格。&lt;/p&gt;

&lt;h2 id=&quot;swiftlint&quot;&gt;Swiftlint&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/realm/SwiftLint&quot;&gt;Swiftlint github link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Swiftlint 是一種靜態程式碼分析工具，可以檢查我們的程式碼是否符合 Swift 的標準風格和最佳實踐。它可以檢測和警告我們的程式碼中的一些常見錯誤和風格問題，例如缺少註釋、空格、括號和命名不一致等。使用 Swiftlint 可以使我們的程式碼更加一致和易於閱讀，從而提高程式碼品質和可維護性。&lt;/p&gt;

&lt;p&gt;你可以使用 –fix 指令，讓 swiftformat 一次處理掉簡單的 format，像是空行等。但這個指令沒辦法處理太複雜的 lint，像是我實測後，他不會移動 trailing closure 中，參數不在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt; 同一行的狀況。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# swiftlint 自動更正指令
swiftlint --fix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;swiftformat&quot;&gt;Swiftformat&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/nicklockwood/SwiftFormat&quot;&gt;Swiftformat github link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;和 swiftformat 是類似的工具，我平常會同時用這兩個工具，因為 lint 的能力不太一樣，這個工具可以調整到 indent 的規範，opaque 型別是不是該處理，甚致細緻到 import 的順序是不是依照英文字母排序。&lt;/p&gt;

&lt;h2 id=&quot;好處&quot;&gt;好處&lt;/h2&gt;

&lt;p&gt;程式碼標準化的好處在於提高程式碼質量和可讀性，從而使得我們的程式碼更加易於維護和擴展。通過使用 Swiftlint 和 Swiftformat，我們可以自動檢測和修正我們的程式碼風格問題，從而使得我們的程式碼更加一致和易於閱讀。此外，這些工具還可以提高我們的開發效率，從而使我們更加專注於開發高品質的應用程式。&lt;/p&gt;

&lt;p&gt;總的來說，Swift 程式碼的標準化是一個重要的主題，它可以幫助我們提高程式碼品質和可讀性，從而使得我們的程式碼更加易於維護和擴展。通過使用 Swiftlint 和 Swiftformat，我們可以自動檢測和修正我們的程式碼風格問題，從而提高我們的開發效率和應用程式的品質。&lt;/p&gt;

&lt;p&gt;繼續來看一下 Swift 程式碼的標準化所帶來的好處。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;透過使用 Swiftlint 和 Swiftformat 我們可以自動化檢測和修正我們的程式碼風格問題，這樣可以節省我們大量的時間和精力，提高我們的開發效率。&lt;/li&gt;
  &lt;li&gt;程式碼標準化可以使得我們的程式碼更加一致和易於閱讀，這樣可以提高程式碼的質量和可維護性。&lt;/li&gt;
  &lt;li&gt;透過程式碼標準化，我們可以使得我們的程式碼更加易於擴展和維護，這樣可以使得我們開發的應用程式更加穩定和可靠。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;總體來說，程式碼標準化是一個非常重要的主題，特別是在大型項目中，它可以使得我們的程式碼更加易於維護和擴展。透過使用 Swiftlint 和 Swiftformat，我們可以自動化檢測和修正我們的程式碼風格問題，提高我們的開發效率和應用程式的品質。如果你還沒有開始使用這些工具，我強烈建議你開始使用它們，這樣可以使得你專案的程式碼更加易於閱讀、維護和擴展。&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="swift" /><category term="swift" /><category term="programming" /><summary type="html">Swift 程式碼的標準化</summary></entry><entry><title type="html">微軟推出了名為「Microsoft 365 Copilot」的新生產力工具</title><link href="http://localhost:4000/programming/2023/03/17/microsoft-office-copilot-launch.html" rel="alternate" type="text/html" title="微軟推出了名為「Microsoft 365 Copilot」的新生產力工具" /><published>2023-03-17T15:41:00+08:00</published><updated>2023-03-17T15:41:00+08:00</updated><id>http://localhost:4000/programming/2023/03/17/microsoft-office-copilot-launch</id><content type="html" xml:base="http://localhost:4000/programming/2023/03/17/microsoft-office-copilot-launch.html">&lt;p&gt;微軟推出了名為「Microsoft 365 Copilot」的新生產力工具，旨在將下一代人工智慧技術應用到工作中，讓使用者能夠更輕鬆地進行創意和生產力的發揮。Copilot整合了大型語言模型（LLMs）和Microsoft Graph和Microsoft 365應用程序中的數據，可將使用者的語言轉化為最強大的生產力工具，幫助使用者更高效地工作。&lt;/p&gt;

&lt;p&gt;Copilot系統可以在Microsoft 365的多種應用程序中使用，例如Word、Excel、PowerPoint、Outlook和Teams，以提高使用者的生產力、解放創造力和升級技能。Copilot還可以在Outlook中協助用戶節省審閱長電子郵件鏈和快速起草建議答覆的時間，而在Teams中，Copilot則可以實時總結關鍵討論點，包括誰說了什麼，人們在哪裡達成了共識，以及哪些地方存在分歧，同時提供建議性行動計劃。Copilot還可以在Excel中分析趨勢和快速創建專業的數據可視化效果。&lt;/p&gt;

&lt;p&gt;除了加速個人生產力之外，Copilot還為每個組織創建了一個新的知識模型，利用現有的數據和見解，實現知識的自由流通，節省寶貴的時間。這使得組織內部的知識更容易被發現和應用，並且節省了大量搜尋答案的時間。Copilot還可以協助自動化重複性任務、創建聊天機器人並在幾分鐘內將想法轉化為實用應用程序。&lt;/p&gt;

&lt;p&gt;微軟表示，Copilot系統的使用需要一定的學習曲線，但是那些採用這種新的工作方式的人將很快取得優勢。微軟聯席CEO Satya Nadella表示，Copilot將徹底改變人們與AI的互動方式，以及AI與人類之間的互動方式。&lt;/p&gt;

&lt;p&gt;Copilot系統是企業級AI的最佳解決方案，不僅整合了OpenAI的ChatGPT，還包括一個複雜的處理和管控引擎，可在企業級應用場景下實現高效穩定的AI模型開發、部署、管理和維護。Copilot系統的開發者希望透過這個產品，幫助企業在應用AI技術方面更加順利，降低開發難度和成本，並且讓企業能夠更好地應對市場和用戶的需求。隨著人工智能技術的發展和應用越來越廣泛，Copilot系統的應用前景也非常看好。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blogs.microsoft.com/blog/2023/03/16/introducing-microsoft-365-copilot-your-copilot-for-work/&quot;&gt;Microsoft blog&lt;/a&gt;&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="programming" /><category term="life" /><summary type="html">微軟推出了名為「Microsoft 365 Copilot」的新生產力工具，旨在將下一代人工智慧技術應用到工作中，讓使用者能夠更輕鬆地進行創意和生產力的發揮。Copilot整合了大型語言模型（LLMs）和Microsoft Graph和Microsoft 365應用程序中的數據，可將使用者的語言轉化為最強大的生產力工具，幫助使用者更高效地工作。</summary></entry><entry><title type="html">Swiftformat 在設定 swiftversion 5.7，會把 T 改成 some Any</title><link href="http://localhost:4000/swift/2023/03/17/swiftformat-version.html" rel="alternate" type="text/html" title="Swiftformat 在設定 swiftversion 5.7，會把 T 改成 some Any" /><published>2023-03-17T09:12:00+08:00</published><updated>2023-03-17T09:12:00+08:00</updated><id>http://localhost:4000/swift/2023/03/17/swiftformat-version</id><content type="html" xml:base="http://localhost:4000/swift/2023/03/17/swiftformat-version.html">&lt;h2 id=&quot;swiftformat-可調整的各種參數&quot;&gt;Swiftformat 可調整的各種參數&lt;/h2&gt;

&lt;p&gt;swiftformat 在進行 formatting  的時候，有很多參數可以調整。詳細的參數如下。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/nicklockwood/SwiftFormat/blob/master/.swiftformat&quot;&gt;swiftformat 參數連結&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# file options

--exclude Tests/XCTestManifests.swift,Tests/BadConfig,Snapshots,Build,PluginTests

# format options

--allman false
--binarygrouping 4,8
--commas always
--decimalgrouping 3,6
--elseposition same-line
--voidtype void
--exponentcase lowercase
--exponentgrouping disabled
--fractiongrouping disabled
--header ignore
--hexgrouping 4,8
--hexliteralcase uppercase
--ifdef indent
--indent 4
--indentcase false
--importgrouping testable-bottom
--linebreaks lf
--maxwidth none
--octalgrouping 4,8
--operatorfunc spaced
--patternlet hoist
--ranges spaced
--self remove
--semicolons inline
--stripunusedargs always
--swiftversion 5.1
--trimwhitespace always
--wraparguments preserve
--wrapcollections preserve

# rules

--enable isEmpty
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;當我們把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--swiftversion 5.1&lt;/code&gt; 調整到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--swiftversion 5.7&lt;/code&gt; 的時候，使用泛型 T，就會被改成 some Any。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// --swiftversion 5.1 ~ 5.6
func log&amp;lt;T&amp;gt;(_ message: T) {

// --swiftversion 5.7
func log(_ message: some Any) {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果仍然不希望 swiftformat 改動 T，那可以在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.swiftformat&lt;/code&gt; 中，加上 disable，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--disable opaqueGenericParameters&lt;/code&gt;。這樣就不會讓 T 改成 some Any 了。&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="swift" /><category term="swift" /><summary type="html">Swiftformat 可調整的各種參數</summary></entry><entry><title type="html">紀錄：瑞士信貸(CSGN)可能會爆發危機2023年3月16日</title><link href="http://localhost:4000/finance/2023/03/16/CSGN-issue-news.html" rel="alternate" type="text/html" title="紀錄：瑞士信貸(CSGN)可能會爆發危機2023年3月16日" /><published>2023-03-16T08:34:00+08:00</published><updated>2023-03-16T08:34:00+08:00</updated><id>http://localhost:4000/finance/2023/03/16/CSGN-issue-news</id><content type="html" xml:base="http://localhost:4000/finance/2023/03/16/CSGN-issue-news.html">&lt;p&gt;在 SVB 倒閉之後，瑞士信代大股東排除將資金繼續注入瑞士信貸，股價在盤中暴跌30%。大股東為沙國銀行，原因為「監管和法規問題」。瑞士信貸去年虧76億瑞郎，直接將10年來的獲利回吐。去年所有的客戶贖回約1000億美元資產，資金仍然持續外流。&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="finance" /><category term="finance" /><category term="news" /><summary type="html">在 SVB 倒閉之後，瑞士信代大股東排除將資金繼續注入瑞士信貸，股價在盤中暴跌30%。大股東為沙國銀行，原因為「監管和法規問題」。瑞士信貸去年虧76億瑞郎，直接將10年來的獲利回吐。去年所有的客戶贖回約1000億美元資產，資金仍然持續外流。</summary></entry><entry><title type="html">紀錄：矽谷銀行(SVB)倒閉於2023年3月10日</title><link href="http://localhost:4000/finance/2023/03/15/SVB-broken-v2.html" rel="alternate" type="text/html" title="紀錄：矽谷銀行(SVB)倒閉於2023年3月10日" /><published>2023-03-15T10:13:00+08:00</published><updated>2023-03-15T10:13:00+08:00</updated><id>http://localhost:4000/finance/2023/03/15/SVB-broken-v2</id><content type="html" xml:base="http://localhost:4000/finance/2023/03/15/SVB-broken-v2.html">&lt;h1 id=&quot;矽谷銀行svb倒閉於2023-03-10&quot;&gt;矽谷銀行(SVB)倒閉於2023-03-10&lt;/h1&gt;

&lt;p&gt;在美國時間2023年3月10日，美國矽谷銀行倒閉。根據 SVB 執行長 Greg Becker 的信，在拋售 210 億美元的債券組合後，稅後損失達到 18 億元。在宣告倒閉後，美國聯邦存款保險公司(FDIC)進行接管。SVB 是 FDIC 接管的銀行中，量體排名第二名的。&lt;/p&gt;

&lt;p&gt;在美國時間 13 日，Fed 和 FDIC 負責人表示。 SVB 儲戶可以順利拿回資產。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在收到 FDIC 和聯準會董事會的建議並與總統協商後，葉倫部長批准了使 FDIC 能夠完成的行動，它以充分保護所有儲戶的方式，對矽谷銀行進行決議。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;為什麼矽谷銀行會倒閉&quot;&gt;為什麼矽谷銀行會倒閉&lt;/h3&gt;

&lt;p&gt;SVB 將資產配置在長期的國債，因為長期國債相對短期有比較好的利率。但在 2022 年開始，美國聯準會不斷的進行加息，這一年中加了八次息。市場利率上升，債券價格就會下跌。SVB 的客戶集中在科技業，在 2022 年底業界發現成長難以持續，不斷進行裁員，在業界景氣進入往下的趨勢中，眾多客戶進行資金轉移，導致了 SVB 需要先拋售持有的長期債券。一般來說，長期債券在長期持有的狀況下，很難賠到錢的，但短期價格是會被市場影響的。&lt;/p&gt;

&lt;h3 id=&quot;後續&quot;&gt;後續&lt;/h3&gt;

&lt;p&gt;美國時間 2023年3月12日，Signature Bank 被關閉，但所有存戶 13 日起可以領回所有存款。&lt;/p&gt;

&lt;h3 id=&quot;twitter-觀點&quot;&gt;Twitter 觀點&lt;/h3&gt;

&lt;p&gt;大賣空主角原型 - 貝瑞在 Twitter 上則是說，這次的危機應該很快就會結束，事情會告一個段落。(不過他還是看空)&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="finance" /><category term="Finance" /><summary type="html">矽谷銀行(SVB)倒閉於2023-03-10</summary></entry><entry><title type="html">GitHub Page 部落格弄好了，未來文章都會 po 在 GitHub Page 上了</title><link href="http://localhost:4000/life/2023/03/14/future-article-will-post-on-page.html" rel="alternate" type="text/html" title="GitHub Page 部落格弄好了，未來文章都會 po 在 GitHub Page 上了" /><published>2023-03-14T21:09:00+08:00</published><updated>2023-03-14T21:09:00+08:00</updated><id>http://localhost:4000/life/2023/03/14/future-article-will-post-on-page</id><content type="html" xml:base="http://localhost:4000/life/2023/03/14/future-article-will-post-on-page.html">&lt;h1 id=&quot;github-page-部落格弄好了未來文章都會-po-在-github-page-上了&quot;&gt;GitHub Page 部落格弄好了，未來文章都會 po 在 GitHub Page 上了&lt;/h1&gt;

&lt;p&gt;最近抽空花了點時間，使用了 ChatGPT 輔助，在 GitHub Page 上架了自己的部落格。使用的是 Ruby 的 Jekyll 框架，Jekyll 也是 GitHub Page 上直接推薦的框架。&lt;/p&gt;

&lt;p&gt;除了 Jekyll 以外，ChatGPT 還推薦了 Hugo、Hexo、Pelican、Gatsby。但我看了 GitHub 官網都推薦 Jekyll 後，就決定先試試 Jekyll 了。&lt;/p&gt;

&lt;p&gt;Github Page&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://moonandeye.github.io/&quot;&gt;https://moonandeye.github.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;現在已經搬移了部分文章，接下來都會繼續在 Page 上寫文章，短期還會在 medium 上貼相同文章，但再過一陣子，我就會停用 medium 了。&lt;/p&gt;

&lt;p&gt;畢竟，我還是想要有一個不是控在別人手上的 blog。&lt;/p&gt;</content><author><name>Marvin Lin</name></author><category term="life" /><category term="Life" /><category term="blog" /><summary type="html">GitHub Page 部落格弄好了，未來文章都會 po 在 GitHub Page 上了</summary></entry></feed>